\page storage_specifiers Storage specifiers

Local variables and parameters have storage specifiers.
These specify whether a variable should be copied or moved in various situations, and whether it is passed by reference or by value.
Aggregate members do not have these specifiers: they must be handled manually, that is, references should be translated to pointers.

Function arguments may have the following storage specifiers, inspired by C++.
However, for us the distinction between l-value and r-value references is simply the behaviour of object moving and copying choices.
There is no notion of const vs. non-const references.
Function argument storage is described by Psi::Compiler::ParameterMode.

<dl>
<dt>Input</dt>
<dd>Used when a function with either not modify an object or will modify it in a way useful to the caller.</dd>
<dt>Output</dt>
<dd>A pure output parameter. It is an error if this is a temporary since the function call is not useful unless this result is captured.</dd>
<dt>Input/Output</dt>
<dd>A parameter used for both input and output.
This is only distinguished from an input parameter by the fact that functional values will not be up-converted to input/output parameters.</dd>
<dt>R-value</dt>
<dd>Used when a function will modify the object destructively so that the caller should use a copy if it would like to use the object again.
This is used (as in C++ r-value references) to implement efficient transfer of resources between objects without needless copying.</dd>
<dt>Functional</dt>
<dd>Used for passing dependent type information.
This currently must be passed in virtual registers since it must be visible to TVMs type system.
Only simple types may be passed this way because object copying and moving semantics cannot be implemented.</dd>
</dl>

Function return values can have the following specifiers:
Return value storage is described by Psi::Compiler::ResultMode.

<dl>
<dt>By value</dt>
<dd>The value is returned to the caller in the caller's stack space.</dd>
<dt>L-value reference</dt>
<dd>A reference to an object.
The caller may explicitly modify the object but should not modify it implicitly by passing it as an R-value reference to another function.</dd>
<dt>R-value reference</dt>
<dd>A reference to an object.
The caller may implicitly and explicitly modify the object.</dd>
</dl>

Local storage breaks down into the following categories:

<dl>
<dt>Functional</dt>
<dd>An object which is constant and lives in registers. It must have a simple type.</dd>
<dt>Stack</dt>
<dd>A normal object, allocated on the stack.</dd>
<dt>L-value reference</dt>
<dd>A pointer to an L-value.</dd>
<dt>R-value reference</dt>
<dd>A pointer to an R-value.
</dl>

The behaviour of these storage types depends on whether the variable in question is about to go out of scope.
In either case, the behaviour is categorised as "Functional", "L-value" or "R-value", as follows:

<a name="scope-exit-var"><table>
<caption>Variable behaviour including scope exit case</caption>
<tr><th>Storage</th><th>Normal behaviour</th><th>At scope exit</th></tr>
<tr><td>Functional</td><td>Functional</td><td>Functional</td></tr>
<tr><td>Stack</td><td>L-value</td><td>R-value</td></tr>
<tr><td>L-value reference</td><td>L-value</td><td>L-value</td></tr>
<tr><td>R-value reference</td><td>L-value</td><td>R-value</td></tr>
</table></a>

Local and parameter storage specifiers lead to the following parameter passing behaviour (note that this is the true definition of the different storage types):

<table>
<tr><td colspan="2" rowspan="2" style="border:0em"></td><th colspan="5">Parameter storage</th></tr>
<tr><th>Input</th><th>Output</th><th>Input/Output</th><th>R-value</th><th>Functional</th></tr>
<tr><th rowspan="3">Local storage</th>
<th>L-value</th><td>Reference</td><td>Reference</td><td>Reference</td><td>Copy</td><td>Error</td>
</tr>
<tr><th>R-value</th><td>Reference</td><td>Error</td><td>Reference</td><td>Reference</td><td>Error</td></tr>
<tr><th>Functional</td><td>Bit-wise copy</td><td>Error</td><td>Error</td><td>Bit-wise copy</td><td>By value</td></tr>
</table>

Some explanations:

<ul>
<li>It is an error to use a functional parameter for output since they are part of the type system and cannot be modified.</li>
<li>It is an error to use an r-value for output since it is expected that an r-value will not accessible after the call, and hence the output data cannot be accessed.</li>
<li>Copy for a functional value is always equivalent to bit wise copy since the type must be simple.</li>
</ul>

For return values, only the local <em>storage</em> is checked, not the local behaviour, since everything is going out of scope in this case,
and it is an error to directly return a reference to a local variable. Note that this can be easily circumvented.

<table>
<tr><td colspan="2" rowspan="2" style="border:0em"></td><th colspan="3">Return storage</th></tr>
<tr><th>By value</th><th>L-value reference</th><th>R-value reference</th></tr>
<tr><th rowspan="4">Local storage</th>
<th>Functional</th><td>Bit-wise copy</td><td>Error</td><td>Error</td></tr>
<tr><th>Stack</th><td>Move</td><td>Error</td><td>Error</td></tr>
<tr><th>L-value reference</th><td>Copy</td><td>Reference</td><td>Error</td></tr>
<tr><th>R-value reference</td><td>Move</td><td>Reference</td><td>Reference</td></tr>
</table>

Jump instruction behaviour is slightly more complex, because some variables are going out of scope and some are not.
Jump argument storage classifiers are the same as return value specifiers.
The l-value and r-value classifications follow the rules in <a href="#scope-exit-var">this table</a>,
however the jump behaviour depends on whether the storage is a reference or not.

<table>
<tr><td colspan="2" rowspan="2" style="border:0em"></td><th colspan="3">Jump argument storage</th></tr>
<tr><th>By value</th><th>L-value reference</th><th>R-value reference</th></tr>
<tr><th rowspan="4">Local storage</th>
<th>Functional</th><td>Bit-wise copy</td><td>Error</td><td>Error</td></tr>
<tr><th>Stack</th><td>Move</td><td>Error</td><td>Error</td></tr>
<tr><th>L-value reference</th><td>Copy</td><td>Reference</td><td>Error</td></tr>
<tr><th>R-value reference</td><td>Move</td><td>Reference</td><td>Reference</td></tr>
</table>
