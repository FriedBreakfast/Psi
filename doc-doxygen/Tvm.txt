\page tvm TVM

TVM is the low level environment used to implement Psi. It is similar to LLVM except that quantified types are supported.

\section tvm_design_decisions Design decisions

\subsection tvm_types_as_variables Types as variables

Types and variables are unified as "terms". This allows types to be passed as parameters.

\subsection tvm_semi_functional_approach Semi-functional approach

There are several types of operation: mutating, functional and type construction. Mutating operations either read or write machine state (\c load, \c store and \c call instructions). Functional operations do not. To see why this separation exists, consider the function type:

<tt>function (a : uiptr, x : (array int a), y : (array int (plus a #up2)) > empty</tt>

Mutating operations cannot possibly appear in a function type, so functional operations must be able to act in this way.

\subsection tvm_exception_handling Exception handling

Exception handling in the presence of these functional operations is somewhat awkward because the results of functional operations which are not used should not be raised. As an example:

<pre>f : function(%%t : bool, %%a : int, %%b : int) > int {
  %%c : div %%a %%b;
  cond_br %%t %%bx %%by;
  
block %%bx:
  return (add %%c #i1);

block %%by:
  return (sub %%c #i1);
}</pre>

In this example, the calculation of \c %%c could raise an exception, however the result is not used until later blocks. In a more complex example it this could span construction of objects and hence change the landing pad for exception unwinding. Therefore, it should not be calculated until it is used. However, the result of such a calculation can be re-used since if the calculation does not raise an exception the first time, it should not on later occurences.

Conversely, a user may choose to try and catch an exception and hence want to control where a calculation is performed. This is much easier to solve since I can include an instruction \c eager in which demands that a calculation has been performed by that point.

\subsection tvm_term_rewriting Term rewriting

LLVM can alter code by changing the values references by an instruction. This is an efficient way to write optimization or other passes since rewriting entire functions is avoided. Currently I am stuck with rewriting everything, since it is possible that once the parameters to a term are changed they could be equivalent to some existing term. As an alternative, I could walk the term tree backwards and update existing terms and seeing if the updated term is equivalent to a pre-existing term, which would be more efficient.

\section tvm_todo TVM To do list

<ul>
<li>\ref tvm_term_rewriting</li>
<li>ApplyTerm</li>
</ul>

\subsection tvm_term_verification Term verification

Currently the validity of each term constructed is checked fairly thoroughly immediately. It is likely that this is inefficient since the user will already know that the constructed code is valid in most cases. Verification should therefore be moved to a separate set of functions at some point.
