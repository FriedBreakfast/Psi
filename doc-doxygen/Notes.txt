\page notes Design notes

\section new_notes New design notes

\subsection nested_functions_2 Nested functions implementation

With nested functions there is the question of how to implement local variable capture. Following C++0x, the basic implementation method should be to create an object with copies of all captured parameters. This object will implement an interface appropriate to the function type, although I'm not sure whether this requires any complex implementation since I can always demand that callback function types are created by defining a new interface, which is probably a good idea anyway since invoking functions is usally done by a wrapper object.

This then begs the question of how to handle parameter capture syntactically. I will implement:

<pre>capture () ...</pre>

Where the dots represent an inner macro invocation to which the capture is applied. When there is no capture any variables may be used from enclosing scopes, however the resulting function object generated will not support the move interface (this may require care since nearly all objects should support this).

I intend to implement a similar method for nested classes and such: the capture macro should enable a child namespace containing multiple classes and functions capturing the same variables to be created. I should also created a method for specifying how captured variables are stored since accidentally copying captured variables will be easy and shared data structures (read: coroutines) could be implemented by capturing variables with appropriate storage scope.

<dl>
<dt>Lookup contexts inside captures</dt>
<dd>Such contexts must separate variables defined inside the capture context from those outside, and then when a variable is used detect whether it is global, and if not capture it and provide a wrapped reference. Note that references to objects captured from an existing capture (i.e. two or more levels up) are treated the same way: they are copied into the enclosing context and then re-copied into the inner context.</dd>
<dt>Storage options for captures</dt>
<dd>Create a capture factory interface which takes the data structure generated by the capture macro and returns the type used to pass the capture (usually with move and possibly with copy semantics), which will act like a single object container so that the enclosed data structure can be extracted. One interface (assign and unwrap) and an appropriate type is needed for this.</dd>
</dl>

Move semantics: it was originally my plan that all objects would be forced to implement move semantics, although this would occasionally cause problems for which require an external reference to them for some reason and probably mean many objects had to implement zombie states. Callback functions seem to break this model since I want automatic captures to fail to run from copies or moves of their target function object. Resolution: it makes sense to remove construct, move and destruct semantics from these objects since moving and copying them is extremely hazardous.

Captures should work as follows: when a closure or inner class is created, the captured data is the resulting object, which must then be wrapped by a macro allowing the member(s) to be accessed normally.

\section nested_functions Nested functions

Nested functions should be implemented at a higher level, where the
data structures should also be optimized. The LLVM code generator must
support injecting value mappings into functions so that variables
passed by function nesting can be easily supported. This means that
individual expressions should not know which function they are part of
since this should not be directly checked, however they should know
whether they are global or not.

\section calling_convention Function calling convention

All functions must be convertible to a generic calling convention
dependent only on the number of parameters since they may be called
from code which doesn't know the parameter types. Therefore:

<ul>
<li>Return type: i8*</li>
<li>n+1 parameters of type i8*</li>
</ul>

When passing a pointer type to a function, the pointer is passed
directly rather than by reference. When a pointer is returned from a
function, the value of the pointer is returned, <em>and</em> the value
of the pointer must be written to the memory area passed for the
return data. Thus, when passing the pointer to another function the
return value is used, and when returning the pointer, memcpy() can be
used to transfer the data from the child to the parent return area.

\section type_variables

Need to add a way of introducing type variables in the low-level
assembler after dereferencing a pointer. The \ref insn_cast and \ref
pointer_offset instructions should also have their \ref type_class
parameters removed and replaced by direct type references: it's
impossible to be totally consistent in syntax at the assembler level.

\section virtual_functions

\verbatim
require List.

Definition vtable := forall (ri : list reverse_lookup), function_pointer int ((pointer interface ri)::nil Set).

Definition interface := forall (ri : list reverse_lookup) (rv : list reverse_lookup), pointer (vtable ri) rv.
\endverbatim

\section terms_and_instructions Terms and instructions

There are three types of term:

<ul>
<li>Functional</li>
<li>Recursive</li>
<li>Instruction</li>
<li>Phi</li>
</ul>

Functional terms should support identical term unification. This can
allow existing terms to be modified, however before this can be done a
check must be made as to whether any previous matching terms exist.

Recursive terms are required to allow construction of self-references
in types.

Instruction terms can have their parameters modified freely. Phi terms
should only have parameters added, and may be unified later.
