/* -*- mode: c++ -*- */

%{
#include <cstring>
#include <memory>

#include "Parser.hpp"
#include "Variant.hpp"

/**
 * the semantic value type for the bison parser. this is also needed by the scanner
 * because it will receive this as a parameter.
 */
#define YYSTYPE ParserValue

/**
 * the location type used by the parser and scanner.
 */
#define YYLTYPE Psi::Parser::PhysicalSourceLocation

/**
 * I previously made this zero - it must be at least one because
 * the generated code assumes it can access the lowest element
 * of the stack before parsing begins.
 *
 * This grammar has a maximum depth, so I should be able to work that
 * out, set this value and everything will "just work". But that seems
 * like a lot of effort.
 */
#define YYINITDEPTH 50

/**
 * I need to use yytype_int16 before it is defined in the generated
 * source code, so this ensures it has the same type as the one I'm
 * using.
 */
#define YYTYPE_INT16 short int

/**
 * Try to ensure that no memory is allocated on the heap by bison
 */
#define YYMALLOC(x)
#define YYFREE(x)
#define YYSTACK_USE_ALLOCA 1

using namespace Psi;
using namespace Psi::Parser;

namespace {
  /**
   * A parser semantic value. Implements a named union type on top of
   * #Variant, so we get exception safety, as well as type checking
   * from bison (via a bit of a syntax abuse in the parser).
   */
  class ParserValue {
  public:
    // this macro only works for types without commas in them
#define PARSER_VALUE(name, type)			     \
    type& name() {return m_value.get<type>();} \
    void name(type value) {m_value = value;}

    PARSER_VALUE(expression, Expression)
    PARSER_VALUE(statement, Statement)
    PARSER_VALUE(argument, Argument)
    PARSER_VALUE(argument_declaration, ArgumentDeclaration)
    PARSER_VALUE(text, PhysicalSourceLocation)
    PARSER_VALUE(argument_declaration_list, std::vector<ArgumentDeclaration>)
    PARSER_VALUE(expression_list, std::vector<Expression>)
    PARSER_VALUE(statement_list, std::vector<Statement>)
    PARSER_VALUE(argument_list, std::vector<Argument>)
    PARSER_VALUE(text_list, std::vector<PhysicalSourceLocation>)

#undef PARSER_VALUE

  private:
    typedef Variant<Expression,
		    Statement,
                    Argument,
		    ArgumentDeclaration,
                    PhysicalSourceLocation,
		    std::vector<Expression>,
		    std::vector<Statement>,
                    std::vector<Argument>,
		    std::vector<ArgumentDeclaration>,
		    std::vector<PhysicalSourceLocation> > InternalStorageType;

    InternalStorageType m_value;
  };

  struct ParserInternalArguments
  {
    ParserInternalArguments(int mode_token_,
                            const PhysicalSourceLocation& text_)
      : mode_token(mode_token_),
        text(text_),
        current(text.begin),
        end(text.end) {
    }

    typedef Variant<std::vector<Statement>,
                    std::vector<Expression>,
                    std::vector<Argument>,
                    std::vector<ArgumentDeclaration> > ResultType;

    int mode_token;
    PhysicalSourceLocation text;
    const char *current, *end;

    ResultType result;
    std::string error_message;

    /**
     * the ratio used to decide the new dynamic stack size from the old. could be
     * any number >1 in theory, but non-integers would require changing the code.
     */
    static const int resize_ratio = 2;


    void overflow(YYTYPE_INT16 **yysp, std::size_t yyssize,
		  YYSTYPE **yyvp, std::size_t yyvsize,
		  YYLTYPE **yylp, std::size_t yylsize,
		  std::size_t *yystacksize) {

      bool copy_stacks = false;
      std::size_t new_size;

      /* apparently these don't hold. I haven't investigated further */
      /*assert(*yystacksize * sizeof(boost::int16_t) == yyssize);
        assert(*yystacksize * sizeof(YYSTYPE) == yyvsize);
        assert(*yystacksize * sizeof(YYLTYPE) == yylsize);*/

      if (!m_parser_state_stack.empty()) {
        assert(&m_parser_state_stack[0] == *yysp);
        assert(!m_parser_value_stack.empty() && (&m_parser_value_stack[0] == *yyvp));
        assert(!m_parser_location_stack.empty() && (&m_parser_location_stack[0] == *yylp));

        assert(*yystacksize == m_parser_state_stack.size());
        assert(*yystacksize == m_parser_value_stack.size());
        assert(*yystacksize == m_parser_location_stack.size());

        new_size = m_parser_state_stack.size() * 2;
      } else {
        copy_stacks = true;
        new_size = *yystacksize * 2;
      }

      m_parser_state_stack.resize(new_size);
      m_parser_value_stack.resize(new_size);
      m_parser_location_stack.resize(new_size);

      if (copy_stacks) {
        std::move(*yysp, *yysp + yyssize / sizeof(**yysp), m_parser_state_stack.begin());
        std::move(*yyvp, *yyvp + yyvsize / sizeof(**yyvp), m_parser_value_stack.begin());
        std::move(*yylp, *yylp + yylsize / sizeof(**yylp), m_parser_location_stack.begin());
      }

      *yysp = &m_parser_state_stack[0];
      *yyvp = &m_parser_value_stack[0];
      *yylp = &m_parser_location_stack[0];
      *yystacksize = new_size;
    }

  private:
    std::vector<YYTYPE_INT16> m_parser_state_stack;
    std::vector<ParserValue> m_parser_value_stack;
    std::vector<PhysicalSourceLocation> m_parser_location_stack;
  };

  void yyerror(const YYLTYPE*,
               ParserInternalArguments& arguments,
               const char *s) {
    arguments.error_message = s;
  }

  /**
   * \brief Checks if a character is a "token" character.
   *
   * A token character is alphanumeric or underscore, so this is
   * equivalent the following in the C locale:
   *
   * \code isalpha(c) || isdigit(c) || c == '_' \endcode
   */
  bool token_char(char c) {
    return ((c >= 'A') && (c <= 'Z')) ||
      ((c >= 'a') && (c <= 'z')) ||
      ((c >= '0') && (c <= '9')) ||
      (c == '_');
  }

  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self);

  template<typename T>
  std::vector<typename std::remove_reference<T>::type> make_list(T&& value) {
    std::vector<typename std::remove_reference<T>::type> v;
    v.push_back(std::move(value));
    return v;
  }

  template<typename T>
  void append_list_helper(std::vector<T>&) {
  }

  template<typename T, typename U, typename... W>
  void append_list_helper(std::vector<T>& vec, U&& value, W&&... more) {
    vec.push_back(std::move(value));
    append_list_helper(vec, std::forward<W>(more)...);
  }

  template<typename T, typename... U>
  std::vector<T> append_list(std::vector<T>& vec, U&&... values) {
    append_list_helper(vec, std::forward<U>(values)...);
    return std::move(vec);
  }

  Expression op_to_expr(const PhysicalSourceLocation& src, const PhysicalSourceLocation& op) {
    return {src, TokenExpression{TokenType::identifier, op}};
  }

  Expression make_binary_expr(const PhysicalSourceLocation& src, const PhysicalSourceLocation& op, Expression& lhs, Expression& rhs) {
    return {src, MacroExpression{{op_to_expr(src, op), std::move(lhs), std::move(rhs)}}};
  }

  Expression make_unary_expr(const PhysicalSourceLocation& src, const PhysicalSourceLocation& op, Expression& arg) {
    return {src, MacroExpression{{op_to_expr(src, op), std::move(arg)}}};
  }

  class ConstSourceCodeOrigin : public SourceCodeOrigin {
  };

  std::shared_ptr<SourceCodeText> const_text_ptr = std::make_shared<SourceCodeText>(SourceCodeText{std::make_shared<ConstSourceCodeOrigin>(), {}});

  /**
   * Convert a constant string to a #PhysicalSourceLocation.
   */
  PhysicalSourceLocation str_loc(const char *s) {
    int len = std::strlen(s);
    return {const_text_ptr, 1, 1, 1, len + 1, s, s + len};
  }

  PhysicalSourceLocation combine_loc(const PhysicalSourceLocation& lhs, const PhysicalSourceLocation& rhs) {
    assert(lhs.text == rhs.text);
    return {lhs.text, lhs.first_line, lhs.first_column, rhs.last_line, rhs.last_column, lhs.begin, rhs.end};
  }
}

#define yyoverflow(msg,yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize) arguments.overflow(yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize)

#define YYLLOC_DEFAULT(current, rhs, N)					\
  do {									\
    if (YYID(N)) {							\
      (current) = combine_loc(YYRHSLOC(rhs, 1), YYRHSLOC(rhs, N));      \
    } else {								\
      const PhysicalSourceLocation& base = YYRHSLOC(rhs, 0);            \
      (current) = PhysicalSourceLocation{arguments.text.text, base.last_line, base.last_column, base.last_line, base.last_column, base.end, base.end}; \
    }									\
  } while (0)
%}

%pure-parser
%locations

/* verbose errors and custom stack allocation (i.e. yyoverflow defined) will not work together in bison */
%error-verbose

%token INVALID
%token IDENTIFIER
%token COMPARE_EQUAL "=="
%token COMPARE_UNEQUAL "!="
%token COMPARE_LESS_EQUAL "<="
%token COMPARE_GREATER_EQUAL ">="
%token OPERATOR_ARROW "->"
%token UNKNOWN "unknown"
%token BLOCK

%token MODE_STATEMENT_LIST
%token MODE_ARGUMENT_LIST
%token MODE_FUNCTION_ARGUMENT_DECLARE

%type <text> IDENTIFIER product_operator add_operator compare_operator unary_operator
%type <statement> statement
%type <statement_list> statement_list
%type <expression> expression or_expression and_expression xor_expression product_expression add_expression unary_expression macro_element compare_expression BLOCK
%type <expression_list> macro_expression compare_expression_build
%type <argument_declaration> argument_declare
%type <argument_declaration_list> argument_list_declare_nonempty argument_list_declare
%type <argument> argument
%type <argument_list> argument_list argument_list_nonempty

%parse-param {ParserInternalArguments& arguments}
%lex-param {ParserInternalArguments& arguments}

%initial-action {
#ifndef YYERROR_VERBOSE
  if (false) {
  yyexhaustedlab:
    YYABORT;
  }
#endif

  @$ = arguments.text;
  @$.end = @$.begin;
}

%%

root: MODE_STATEMENT_LIST statement_list {arguments.result = std::move($2());}
| MODE_ARGUMENT_LIST argument_list {arguments.result = std::move($2());}
| MODE_FUNCTION_ARGUMENT_DECLARE argument_list_declare {arguments.result = std::move($2());}
;

argument_list: /* blank */ {$$({});}
| argument_list_nonempty {$$(std::move($1()));}
;

argument_list_nonempty:
argument {$$(make_list($1()));}
| argument_list_nonempty ',' argument {$$(append_list($1(), $3()));}
;

argument:
expression {$$({@$, std::move($1())});}
;

argument_list_declare: /* blank */ {$$({});}
| argument_list_declare_nonempty
;

argument_list_declare_nonempty:
argument_declare {$$(make_list($1()));}
| argument_list_declare_nonempty ',' argument_declare {$$(append_list($1(), $3()));}
;

argument_declare:
IDENTIFIER {$$(ArgumentDeclaration{@$, $1()});}
| IDENTIFIER ':' expression {$$(ArgumentDeclaration{@$, $1(), $3()});}
;

statement_list:
statement {$$(make_list($1()));}
| statement_list ';' statement {$$(append_list($1(), $3()));}
;

statement:
/* blank */ {$$(Statement{@$});}
| expression {$$(Statement{@$, $1()});}
| IDENTIFIER ':' expression {$$(Statement{@$, $3(), $1()});}
;

expression:
or_expression
| expression '=' or_expression {$$(make_binary_expr(@$, str_loc("="), $1(), $3()))};
;

or_expression:
xor_expression
| or_expression '|' xor_expression {$$(make_binary_expr(@$, str_loc("|"), $1(), $3()));}
;

xor_expression:
and_expression
| xor_expression '^' and_expression {$$(make_binary_expr(@$, str_loc("^"), $1(), $3()));}
;

and_expression:
compare_expression
| and_expression '&' compare_expression {$$(make_binary_expr(@$, str_loc("&"), $1(), $3()));}
;

compare_expression:
add_expression
| compare_expression_build {$1().insert($1().begin(), op_to_expr(@$, str_loc(":cmp"))); $$({@$, MacroExpression{std::move($1())}});}
;

compare_expression_build:
add_expression compare_operator add_expression {$$({$1(), op_to_expr(@$, $2()), $3()});}
| compare_expression_build compare_operator add_expression {$$(append_list($1(), op_to_expr(combine_loc($1().back().source, @3), $2()), $3()));}
;

compare_operator:
COMPARE_EQUAL {$$(str_loc("=="));}
| COMPARE_UNEQUAL {$$(str_loc("!="));}
| COMPARE_GREATER_EQUAL {$$(str_loc(">="));}
| COMPARE_LESS_EQUAL {$$(str_loc("<="));}
| '<' {$$(str_loc("<"));}
| '>' {$$(str_loc(">"));}
;

add_expression:
product_expression
| add_expression add_operator product_expression {$$(make_binary_expr(@$, $2(), $1(), $3()));}
;

add_operator:
'+' {$$(str_loc("+"));}
| '-' {$$(str_loc("-2"));}
;

product_expression:
unary_expression
| product_expression product_operator unary_expression {$$(make_binary_expr(@$, $2(), $1(), $3()));}
;

product_operator:
'*' {$$(str_loc("*"));}
| '/' {$$(str_loc("/"));}
| '%' {$$(str_loc("%"));}
;

unary_expression:
macro_expression {$$({@$, MacroExpression{std::move($1())}});}
| unary_operator unary_expression {$$(make_unary_expr(@$, $1(), $2()));}
;

unary_operator:
'-' {$$(str_loc("-1"));}
| '!' {$$(str_loc("!"));}
;

macro_expression:
 macro_element {$$(make_list($1()));}
| macro_expression macro_element {$$(append_list($1(), $2()));}
;

macro_element:
IDENTIFIER {$$({@$, TokenExpression{TokenType::identifier, @$}});}
| BLOCK
;

%%

namespace {
  /**
   * \brief Scanner function.
   *
   * I've done this as a handwritten function rather than using Flex
   * because bending Flex to my will seems like slightly more effort
   * than doing this. I'd like it to be able to operate on a buffer
   * without altering it, which this function does, and it takes less
   * code than Flex and the myriad of options required to make a Flex
   * scanner sensible.
   *
   * \note Note that this function lives here rather than above the
   * main parser body (where it is declared) because it required the
   * parser token definitions.
   */
  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self) {
    char c;

    if (self.mode_token != 0) {
      int result = self.mode_token;
      self.mode_token = 0;
      return result;
    }

  next_char:
    llocp->begin = llocp->end;
    assert(llocp->begin.base() == &*self.current);

    if (self.current == self.end)
      return 0;

#define SCANNER_RETURN(val) do {lvalp->text(*llocp); return (val);} while(0)
#define SCANNER_ACCEPT() (++self.current, ++llocp->end)

    c = *self.current;

    if (token_char(c)) {
      do {
        SCANNER_ACCEPT();
      } while ((self.current != self.end) && token_char(*self.current));
      SCANNER_RETURN(IDENTIFIER);
    } else if (std::strchr("<>=!", c)) {
      /* Multi-char comparison operators */
      SCANNER_ACCEPT();
      if ((self.current != self.end) && (*self.current == '=')) {
        SCANNER_ACCEPT();
        switch(c) {
        case '>': SCANNER_RETURN(COMPARE_GREATER_EQUAL);
        case '<': SCANNER_RETURN(COMPARE_LESS_EQUAL);
        case '=': SCANNER_RETURN(COMPARE_EQUAL);
        case '!': SCANNER_RETURN(COMPARE_UNEQUAL);
        default: std::abort();
        }
      } else {
        return c;
      }
    } else if (c == '-') {
      /* Arrow operator "->" */
      SCANNER_ACCEPT();
      if ((self.current != self.end) && (*self.current == '>')) {
        SCANNER_ACCEPT();
        return OPERATOR_ARROW;
      } else {
        return '-';
      }
    } else if (std::strchr(".:;,+*/%^&|", c)) {
      SCANNER_ACCEPT();
      SCANNER_RETURN(c);
    } else if (std::strchr("{[(", c)) {
      int brace_depth = 0, square_bracket_depth = 0, bracket_depth = 0;
      TokenType me_type;

      switch(c) {
      case '(': me_type = TokenType::bracket; break;
      case '[': me_type = TokenType::square_bracket; break;
      case '{': me_type = TokenType::brace; break;
      default: std::abort();
      }

      while(1) {
        c = *self.current;
        SCANNER_ACCEPT();

        if (c == '\\') {
          if (self.current == self.end)
            SCANNER_RETURN(INVALID);
          SCANNER_ACCEPT();
        } else if (c == '{') {
          ++brace_depth;
        } else if (c == '}') {
          if (brace_depth == 0)
            SCANNER_RETURN(INVALID);
          --brace_depth;
        } else if (brace_depth == 0) {
          if (c == '[') {
            ++square_bracket_depth;
          } else if (c == ']') {
            if (square_bracket_depth == 0)
              SCANNER_RETURN(INVALID);
            --square_bracket_depth;
          } else if (square_bracket_depth == 0) {
            if (c == '(') {
              ++bracket_depth;
            } else if (c == ')') {
              if (bracket_depth == 0)
                SCANNER_RETURN(INVALID);
              --bracket_depth;
            }
          }
        }

        if ((bracket_depth == 0) && (square_bracket_depth == 0) && (brace_depth == 0)) {
          PhysicalSourceLocation value_text(*llocp);
          ++value_text.begin;
          --value_text.end;
          lvalp->expression({*llocp, TokenExpression{me_type, value_text}});
          return BLOCK;
        } else if (self.current == self.end) {
          SCANNER_RETURN(INVALID);
        }
      }
    } else if (std::strchr(" \t\r\v", c)) {
      SCANNER_ACCEPT();
      goto next_char;
    } else if (c == '\n') {
      SCANNER_ACCEPT();
      goto next_char;
    } else {
      return c;
    }

#undef SCANNER_ADVANCE
  }

  template<typename T> T parse_helper(int mode, const PhysicalSourceLocation& text) {
    ParserInternalArguments internal(mode, text);

    int result = yyparse(internal);

    if (result == 0) {
      return internal.result.get<T>();
    } else {
      throw ParseError(internal.error_message);
    }
  }
}

namespace Psi {
  namespace Parser {
    ParseError::ParseError(const std::string& reason) : std::runtime_error(reason) {
    }

    ParseError::~ParseError() throw() {
    }

    std::vector<Statement> parse_statement_list(const PhysicalSourceLocation& text) {
      return parse_helper<std::vector<Statement> >(MODE_STATEMENT_LIST, text);
    }

    std::vector<Argument> parse_argument_list(const PhysicalSourceLocation& text) {
      return parse_helper<std::vector<Argument> >(MODE_ARGUMENT_LIST, text);
    }

    std::vector<ArgumentDeclaration> parse_function_argument_declaration(const PhysicalSourceLocation& text) {
      return parse_helper<std::vector<ArgumentDeclaration> >(MODE_FUNCTION_ARGUMENT_DECLARE, text);
    }
  }
}
