/* -*- mode: c++ -*- */

%{
#include <cstring>
#include <memory>

#include "Parser.hpp"
#include "ParserUtility.hpp"
#include "Utility.hpp"

/**
 * the semantic value type for the bison parser. this is also needed by the scanner
 * because it will receive this as a parameter.
 */
#define YYSTYPE ParserValue

/**
 * the location type used by the parser and scanner.
 */
#define YYLTYPE Psi::Parser::Location

/**
 * I previously made this zero - it must be at least one because
 * the generated code assumes it can access the lowest element
 * of the stack before parsing begins.
 *
 * This grammar has a maximum depth, so I should be able to work that
 * out, set this value and everything will "just work". But that seems
 * like a lot of effort.
 */
#define YYINITDEPTH 50

/**
 * I need to use yytype_int16 before it is defined in the generated
 * source code, so this ensures it has the same type as the one I'm
 * using.
 */
#define YYTYPE_INT16 short int

/**
 * Try to ensure that no memory is allocated on the heap by bison
 */
#define YYMALLOC(x)
#define YYFREE(x)
#define YYSTACK_USE_ALLOCA 1

using namespace Psi;
using namespace Psi::Parser;
using namespace Psi::ParserUtility;

namespace {
  struct ParserValue {
    const char *cstr;
    Location text;
    boost::shared_ptr<UniqueList<Expression> > expressions;
    boost::shared_ptr<UniqueList<NamedExpression> > named_expressions;
  };

  struct ParserInternalArguments : BisonHelper<YYTYPE_INT16, YYSTYPE, YYLTYPE> {
    ParserInternalArguments(int mode_token_, const char *begin_, const char *end_)
      : mode_token(mode_token_), current(begin_), end(end_) {
    }

    UniqueList<Expression> result_expressions;
    UniqueList<NamedExpression> result_named_expressions;

    int mode_token;
    const char *current, *end;

    std::string error_message;
  };

  void yyerror(const YYLTYPE*,
               ParserInternalArguments& arguments,
               const char *s) {
    arguments.error_message = s;
  }

  /**
   * \brief Checks if a character is a "token" character.
   *
   * A token character is alphanumeric or underscore, so this is
   * equivalent the following in the C locale:
   *
   * \code isalpha(c) || isdigit(c) || c == '_' \endcode
   */
  bool token_char(char c) {
    return ((c >= 'A') && (c <= 'Z')) ||
      ((c >= 'a') && (c <= 'z')) ||
      ((c >= '0') && (c <= '9')) ||
      (c == '_');
  }

  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self);

#if 0
  /**
   * Convert a constant string to a #PhysicalSourceLocation.
   */
  PhysicalSourceLocation str_loc(const char *s) {
    PhysicalSourceLocation p;
    p.text = const_text_ptr;
    p.first_line = p.last_line = 1;
    p.first_column = p.last_column = 1;
    p.begin = p.end = s;

    for (; *p.end != '\0'; ++p.end, ++p.last_column) {
      if (*p.end == '\n') {
	p.last_line++;
	p.last_column = 1;
      }
    }

    return p;
  }
#endif

  Location combine_loc(const Location& lhs, const Location& rhs) {
    Location p;
    p.first_line = lhs.first_line;
    p.first_column = lhs.first_column;
    p.begin = lhs.begin;
    p.last_line = rhs.last_line;
    p.last_column = rhs.last_column;
    p.end = rhs.end;
    return p;
  }

  Location end_loc(const Location& base) {
    Location p;
    p.first_line = p.last_line = base.last_line;
    p.first_column = p.last_column = base.last_column;
    p.begin = p.end = base.end;
    return p;
  }

  Expression* str_expression(const Location& loc, const char *op) {
    // this might be dodgy - the number of characters given by
    // line/column numbers does not relate to the number of characters
    // in the "op" string.

    Location text = loc;
    text.begin = op;
    text.end = op + std::strlen(op);

    return new TokenExpression(loc, TokenExpression::identifier, text);
  }

  boost::shared_ptr<UniqueList<Expression> > binary_expr(const Location& origin,
							 const Location& op_loc, const char *op,
							 boost::shared_ptr<UniqueList<Expression> >& lhs,
							 boost::shared_ptr<UniqueList<Expression> >& rhs) {
    PSI_ASSERT(lhs->size() == 1);
    PSI_ASSERT(rhs->size() == 1);

    UniqueList<Expression> args;
    args.push_back(*str_expression(op_loc, op));
    args.splice(args.end(), *lhs);
    lhs.reset();
    args.splice(args.end(), *rhs);
    rhs.reset();

    return list_one<Expression>(new MacroExpression(origin, args));
  }

  boost::shared_ptr<UniqueList<Expression> > unary_expr(const Location& origin,
							const Location& op_loc, const char *op,
							boost::shared_ptr<UniqueList<Expression> >& param) {
    PSI_ASSERT(param->size() == 1);

    UniqueList<Expression> args;
    args.push_back(*str_expression(op_loc, op));
    args.splice(args.end(), *param);

    return list_one<Expression>(new MacroExpression(origin, args));
  }
}

#define yyoverflow(msg,yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize) arguments.overflow(yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize)

#define YYLLOC_DEFAULT(current, rhs, N)					\
  do {									\
    if (YYID(N)) {							\
      (current) = combine_loc(YYRHSLOC(rhs, 1), YYRHSLOC(rhs, N));      \
    } else {								\
      (current) = end_loc(YYRHSLOC(rhs, 0));				\
    }									\
  } while (0)
%}

%pure-parser
%locations

/* verbose errors and custom stack allocation (i.e. yyoverflow defined) will not work together in bison */
%error-verbose

%token INVALID
%token IDENTIFIER
%token COMPARE_EQUAL "=="
%token COMPARE_UNEQUAL "!="
%token COMPARE_LESS_EQUAL "<="
%token COMPARE_GREATER_EQUAL ">="
%token OPERATOR_ARROW "->"
%token UNKNOWN "unknown"
%token BLOCK

%token MODE_STATEMENT_LIST
%token MODE_ARGUMENT_LIST
%token MODE_FUNCTION_ARGUMENT_DECLARE

%type <text> IDENTIFIER
%type <cstr> product_operator add_operator compare_operator unary_operator
%type <expressions> BLOCK expression or_expression and_expression xor_expression product_expression add_expression unary_expression macro_element compare_expression macro_expression compare_expression_build
%type <named_expressions> statement statement_list argument_list_declare_nonempty argument_list_declare argument_list argument_list_nonempty named_expression

%parse-param {ParserInternalArguments& arguments}
%lex-param {ParserInternalArguments& arguments}

%initial-action {
#ifndef YYERROR_VERBOSE
  if (false) {
  yyexhaustedlab:
    YYABORT;
  }
#endif

  @$.begin = @$.end = arguments.current;
  @$.first_line = 1;
  @$.first_column = 1;
  @$.last_line = 1;
  @$.last_column = 1;
}

%%

root: MODE_STATEMENT_LIST statement_list {arguments.result_named_expressions.swap(*$2);}
| MODE_FUNCTION_ARGUMENT_DECLARE argument_list_declare {arguments.result_named_expressions.swap(*$2);}
| MODE_ARGUMENT_LIST argument_list {arguments.result_named_expressions.swap(*$2);}
;

argument_list: {$$ = list_empty<NamedExpression>();}
| argument_list_nonempty
;

argument_list_nonempty:
named_expression
| argument_list_nonempty ',' named_expression {$$ = list_append($1, $3);}
;

argument_list_declare: /* blank */ {$$ = list_empty<NamedExpression>();}
| argument_list_declare_nonempty
;

argument_list_declare_nonempty:
named_expression
| argument_list_declare_nonempty ',' named_expression {$$ = list_append($1, $3);}
;

statement_list:
statement
| statement_list ';' statement {$$ = list_append($1, $3);}
;

statement:
{$$ = list_one<NamedExpression>(new NamedExpression(@$));}
| named_expression
;

named_expression:
expression {
  UniquePtr<Expression> expr(list_to_ptr($1));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, expr));
}
| IDENTIFIER ':' expression {
  UniquePtr<Expression> expr(list_to_ptr($3));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, expr, $1));
}
;

expression:
or_expression
| expression '=' or_expression {$$ = binary_expr(@$, @2, "=", $1, $3);};
;

or_expression:
xor_expression
| or_expression '|' xor_expression {$$ = binary_expr(@$, @2, "|", $1, $3);}
;

xor_expression:
and_expression
| xor_expression '^' and_expression {$$ = binary_expr(@$, @2, "^", $1, $3);}
;

and_expression:
compare_expression
| and_expression '&' compare_expression {$$ = binary_expr(@$, @2, "&", $1, $3);}
;

compare_expression:
add_expression
| compare_expression_build {
  $$ = list_one<Expression>(str_expression(@0, ":cmp"));
  $$->splice($$->end(), *$1);
}
;

compare_expression_build:
add_expression compare_operator add_expression {
  $$ = list_empty<Expression>();
  $$->push_back(*list_to_ptr($1));
  $$->push_back(*str_expression(@2, $2));
  $$->push_back(*list_to_ptr($3));
}
| compare_expression_build compare_operator add_expression {
  $$.swap($1); $1.reset();
  $$->push_back(*str_expression(@2, $2));
  $$->push_back(*list_to_ptr($3));
}
;

compare_operator:
COMPARE_EQUAL {$$ = "==";}
| COMPARE_UNEQUAL {$$ = "!=";}
| COMPARE_GREATER_EQUAL {$$ = ">=";}
| COMPARE_LESS_EQUAL {$$ = "<=";}
| '<' {$$ = "<";}
| '>' {$$ = ">";}
;

add_expression:
product_expression
| add_expression add_operator product_expression {$$ = binary_expr(@$, @2, $2, $1, $3);}
;

add_operator: '+' {$$="+";} | '-' {$$="-2";};

product_expression:
unary_expression
| product_expression product_operator unary_expression {$$ = binary_expr(@$, @2, $2, $1, $3);}
;

product_operator: '*' {$$="*";} | '/' {$$="/";} | '%' {$$="%";};

unary_expression:
macro_expression {$$ = list_one<Expression>(new MacroExpression(@$, *$1));}
| unary_operator unary_expression {$$ = unary_expr(@$, @1, $1, $2);}
;

unary_operator:
'-' {$$ = "-1";}
| '!' {$$ = "!";}
;

macro_expression:
macro_element
| macro_expression macro_element {$$ = list_append($1, $2);}
;

macro_element:
IDENTIFIER {$$ = list_one<Expression>(new TokenExpression(@$, TokenExpression::identifier, $1));}
| BLOCK
;

%%

namespace {
  /**
   * \brief Scanner function.
   *
   * I've done this as a handwritten function rather than using Flex
   * because bending Flex to my will seems like slightly more effort
   * than doing this. I'd like it to be able to operate on a buffer
   * without altering it, which this function does, and it takes less
   * code than Flex and the myriad of options required to make a Flex
   * scanner sensible.
   *
   * \note Note that this function lives here rather than above the
   * main parser body (where it is declared) because it required the
   * parser token definitions.
   */
  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self) {
    char c;

    if (self.mode_token != 0) {
      int result = self.mode_token;
      self.mode_token = 0;
      return result;
    }

  next_char:
    llocp->begin = llocp->end;
    llocp->first_line = llocp->last_line;
    llocp->first_column = llocp->last_column;
    PSI_ASSERT(llocp->begin == self.current);

    if (self.current == self.end)
      return 0;

#define SCANNER_RETURN(val) do {lvalp->text = *llocp; return (val);} while(0)
#define SCANNER_ACCEPT() (++self.current, ++llocp->end, ++llocp->last_column)

    c = *self.current;

    if (token_char(c)) {
      do {
        SCANNER_ACCEPT();
      } while ((self.current != self.end) && token_char(*self.current));
      SCANNER_RETURN(IDENTIFIER);
    } else if (std::strchr("<>=!", c)) {
      /* Multi-char comparison operators */
      SCANNER_ACCEPT();
      if ((self.current != self.end) && (*self.current == '=')) {
        SCANNER_ACCEPT();
        switch(c) {
        case '>': SCANNER_RETURN(COMPARE_GREATER_EQUAL);
        case '<': SCANNER_RETURN(COMPARE_LESS_EQUAL);
        case '=': SCANNER_RETURN(COMPARE_EQUAL);
        case '!': SCANNER_RETURN(COMPARE_UNEQUAL);
        default: std::abort();
        }
      } else {
        return c;
      }
    } else if (c == '-') {
      /* Arrow operator "->" */
      SCANNER_ACCEPT();
      if ((self.current != self.end) && (*self.current == '>')) {
        SCANNER_ACCEPT();
        return OPERATOR_ARROW;
      } else {
        return '-';
      }
    } else if (std::strchr(".:;,+*/%^&|", c)) {
      SCANNER_ACCEPT();
      SCANNER_RETURN(c);
    } else if (std::strchr("{[(", c)) {
      int brace_depth = 0, square_bracket_depth = 0, bracket_depth = 0;
      TokenExpression::TokenType block_type;

      switch(c) {
      case '(': block_type = TokenExpression::bracket; break;
      case '[': block_type = TokenExpression::square_bracket; break;
      case '{': block_type = TokenExpression::brace; break;
      default: PSI_FAIL("should not reach this point");
      }

      while(1) {
        c = *self.current;
        SCANNER_ACCEPT();

        if (c == '\\') {
          if (self.current == self.end)
            SCANNER_RETURN(INVALID);
          SCANNER_ACCEPT();
        } else if (c == '{') {
          ++brace_depth;
        } else if (c == '}') {
          if (brace_depth == 0)
            SCANNER_RETURN(INVALID);
          --brace_depth;
        } else if (brace_depth == 0) {
          if (c == '[') {
            ++square_bracket_depth;
          } else if (c == ']') {
            if (square_bracket_depth == 0)
              SCANNER_RETURN(INVALID);
            --square_bracket_depth;
          } else if (square_bracket_depth == 0) {
            if (c == '(') {
              ++bracket_depth;
            } else if (c == ')') {
              if (bracket_depth == 0)
                SCANNER_RETURN(INVALID);
              --bracket_depth;
            }
          }
        }

        if ((bracket_depth == 0) && (square_bracket_depth == 0) && (brace_depth == 0)) {
          Location value_text(*llocp);
          ++value_text.begin;
          --value_text.end;
	  lvalp->expressions = list_one<Expression>(new TokenExpression(*llocp, block_type, *llocp));
          return BLOCK;
        } else if (self.current == self.end) {
          SCANNER_RETURN(INVALID);
        }
      }
    } else if (std::strchr(" \t\r\v", c)) {
      SCANNER_ACCEPT();
      goto next_char;
    } else if (c == '\n') {
      SCANNER_ACCEPT();
      llocp->last_line++;
      llocp->last_column = 1;
      goto next_char;
    } else {
      return c;
    }

#undef SCANNER_ADVANCE
  }

  void parse_helper(ParserInternalArguments& internal) {
    int result = yyparse(internal);
    if (result)
      throw ParseError(internal.error_message);
  }
}

namespace Psi {
  namespace Parser {
    Element::Element(const Location& location_)
      : location(location_) {
    }

    Expression::Expression(const Location& location_, ExpressionType expression_type_)
      : Element(location_),
	expression_type(expression_type_) {
    }

    Expression::~Expression() {
    }

    TokenExpression::TokenExpression(const Location& location_, TokenType token_type_, const Location& text_)
      : Expression(location_, expression_token),
	token_type(token_type_),
	text(text_) {
    }

    TokenExpression::~TokenExpression() {
    }

    MacroExpression::MacroExpression(const Location& location_, UniqueList<Expression>& elements_)
      : Expression(location_, expression_macro) {
      elements.swap(elements_);
    }

    MacroExpression::~MacroExpression() {
    }

    NamedExpression::NamedExpression(const Location& source_)
      : Element(source_) {
    }

    NamedExpression::NamedExpression(const Location& source_, UniquePtr<Expression>& expression_)
      : Element(source_) {
      expression.swap(expression_);
    }

    NamedExpression::NamedExpression(const Location& source_, UniquePtr<Expression>& expression_, const Location& name_)
      : Element(source_),
	name(name_) {
      expression.swap(expression_);
    }

    NamedExpression::~NamedExpression() {
    }

    ParseError::ParseError(const std::string& reason) : std::runtime_error(reason) {
    }

    ParseError::~ParseError() throw() {
    }

    void parse_statement_list(const char *begin, const char *end, UniqueList<NamedExpression>& result) {
      ParserInternalArguments args(MODE_STATEMENT_LIST, begin, end);
      parse_helper(args);
      result.swap(args.result_named_expressions);
    }

    void parse_argument_list(const char *begin, const char *end, UniqueList<NamedExpression>& result) {
      ParserInternalArguments args(MODE_ARGUMENT_LIST, begin, end);
      parse_helper(args);
      result.swap(args.result_named_expressions);
    }

    void parse_function_argument_declaration(const char *begin, const char *end, UniqueList<NamedExpression>& result) {
      ParserInternalArguments args(MODE_FUNCTION_ARGUMENT_DECLARE, begin, end);
      parse_helper(args);
      result.swap(args.result_named_expressions);
    }
  }
}
