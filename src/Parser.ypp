/* -*- mode: c++ -*- */

%{
#include <cstring>
#include <memory>
#include <boost/format.hpp>

#include "Parser.hpp"
#include "ParserUtility.hpp"
#include "Utility.hpp"

/**
 * the semantic value type for the bison parser. this is also needed by the scanner
 * because it will receive this as a parameter.
 */
#define YYSTYPE ParserValue

/**
 * the location type used by the parser and scanner.
 */
#define YYLTYPE ::Psi::Parser::ParserLocation

/**
 * I previously made this zero - it must be at least one because
 * the generated code assumes it can access the lowest element
 * of the stack before parsing begins.
 *
 * This grammar has a maximum depth, so I should be able to work that
 * out, set this value and everything will "just work". But that seems
 * like a lot of effort.
 */
#define YYINITDEPTH 50

/**
 * I need to use yytype_int16 before it is defined in the generated
 * source code, so this ensures it has the same type as the one I'm
 * using.
 */
#define YYTYPE_INT16 short int

/**
 * Try to ensure that no memory is allocated on the heap by bison
 */
#define YYMALLOC(x)
#define YYFREE(x)
#define YYSTACK_USE_ALLOCA 1

#ifdef _MSC_VER
#include <malloc.h>
#define YYSTACK_ALLOC _alloca
#endif

using namespace Psi;
using namespace Psi::Parser;

namespace {
  struct ParserValue {
    int int_value;
    const char *cstr;
    ParserLocation text;

    SharedPtr<TokenExpression> token_expression;
    
    SharedPtr<Expression> expression;
    PSI_STD::vector<SharedPtr<Expression> > expression_list;

    SharedPtr<Statement> statement;
    PSI_STD::vector<SharedPtr<Statement> > statement_list;

    SharedPtr<FunctionArgument> function_argument;
    PSI_STD::vector<SharedPtr<FunctionArgument> > function_argument_list;
    
    SharedPtr<Implementation> implementation;
    PSI_STD::vector<SharedPtr<Implementation> > implementation_list;
    
    PSI_STD::vector<SharedPtr<Lifecycle> > lifecycle_list;
  };

  struct ParserInternalArguments : BisonHelper<YYTYPE_INT16, YYSTYPE, YYLTYPE> {
    ParserInternalArguments(int mode_token_, const ParserLocation& text_)
      : mode_token(mode_token_), bracket_literal(false), text(text_), current(text_.begin), end(text_.end) {
    }

    PSI_STD::vector<SharedPtr<Expression> > result_expressions;
    PSI_STD::vector<SharedPtr<Statement> > result_statements;
    PSI_STD::vector<SharedPtr<Implementation> > result_implementations;
    PSI_STD::vector<SharedPtr<Lifecycle> > result_lifecycle;
    ArgumentDeclarations result_argument_declarations;
    ImplicitArgumentDeclarations result_argument_implicit;

    int mode_token;
    bool bracket_literal;
    ParserLocation text;
    const char *current, *end;

    std::string error_message;
    PhysicalSourceLocation error_location;
  };

  void yyerror(const YYLTYPE *loc,
               ParserInternalArguments& arguments,
               const char *s) {
    arguments.error_message = s;
    arguments.error_location = loc->location;
  }

  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self);

  ParserLocation combine_loc(const ParserLocation& lhs, const ParserLocation& rhs) {
    PSI_ASSERT(lhs.location.file == rhs.location.file);
    ParserLocation p;
    p.location.file = lhs.location.file;
    p.location.first_line = lhs.location.first_line;
    p.location.first_column = lhs.location.first_column;
    p.begin = lhs.begin;
    p.location.last_line = rhs.location.last_line;
    p.location.last_column = rhs.location.last_column;
    p.end = rhs.end;
    return p;
  }

  ParserLocation end_loc(const ParserLocation& base) {
    ParserLocation p;
    p.location.file = base.location.file;
    p.location.first_line = p.location.last_line = base.location.last_line;
    p.location.first_column = p.location.last_column = base.location.last_column;
    p.begin = p.end = base.end;
    return p;
  }

  SharedPtr<Expression> str_expression(const ParserLocation& loc, const char *op) {
    ParserLocation text = loc;
    text.begin = op;
    text.end = op + std::strlen(op);

    return SharedPtr<Expression>(new TokenExpression(loc, TokenExpression::identifier, text));
  }

  SharedPtr<Expression> binary_expr(const ParserLocation& origin,
                                    const ParserLocation& op_loc, const char *op,
                                    const SharedPtr<Expression>& lhs,
                                    const SharedPtr<Expression>& rhs) {
    PSI_STD::vector<SharedPtr<Expression> > args;
    args.push_back(lhs);
    args.push_back(rhs);

    return SharedPtr<Expression>(new EvaluateExpression(origin, str_expression(op_loc, op), args));
  }

  SharedPtr<Expression> unary_expr(const ParserLocation& origin,
                                   const ParserLocation& op_loc, const char *op,
                                   const SharedPtr<Expression>& param) {
    PSI_STD::vector<SharedPtr<Expression> > args;
    args.push_back(param);

    return SharedPtr<Expression>(new EvaluateExpression(origin, str_expression(op_loc, op), args));
  }
}

#define yyoverflow(msg,yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize) arguments.overflow(yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize)

#define YYLLOC_DEFAULT(current, rhs, N)					\
  do {									\
    if (YYID(N)) {							\
      (current) = combine_loc(YYRHSLOC(rhs, 1), YYRHSLOC(rhs, N));      \
    } else {								\
      (current) = end_loc(YYRHSLOC(rhs, 0));				\
    }									\
  } while (0)
%}

%pure-parser
%locations

/* verbose errors and custom stack allocation (i.e. yyoverflow defined) will not work together in bison */
%error-verbose

%token INVALID
%token IDENTIFIER
%token NUMBER
%token COMPARE_EQUAL "=="
%token COMPARE_UNEQUAL "!="
%token COMPARE_LESS_EQUAL "<="
%token COMPARE_GREATER_EQUAL ">="

%token OPERATOR_ARROW "->"
%token OPERATOR_DASH_COLON "-:"
%token OPERATOR_DASH_AMP "-&"
%token OPERATOR_DASH_AMP_AMP "-&&"

%token OPERATOR_DOUBLE_COLON "::"
%token OPERATOR_COLON_AMP ":&"
%token OPERATOR_COLON_AMP_AMP ":&&"
%token OPERATOR_COLON_RIGHT ":>"

%token UNKNOWN "unknown"
%token BLOCK

%token MODE_STATEMENT_LIST
%token MODE_POSITIONAL_LIST
%token MODE_NAMESPACE
%token MODE_FUNCTION_ARGUMENT_DECLARE
%token MODE_FUNCTION_ARGUMENT_IMPLICIT
%token MODE_EXPRESSION
%token MODE_IMPLEMENTATION_LIST
%token MODE_LIFECYCLE

%type <text> IDENTIFIER NUMBER
%type <int_value> return_mode argument_mode statement_mode
%type <cstr> product_operator add_operator compare_operator unary_operator
%type <token_expression> BLOCK
%type <expression> expression or_expression and_expression xor_expression product_expression add_expression
%type <expression> unary_expression compare_expression macro_expression token_expression
%type <expression_list> compare_expression_build expression_list expression_list_nonempty token_list interface_list_declare interface_list_declare_nonempty
%type <statement> statement namespace_entry
%type <statement_list> statement_list namespace_list
%type <function_argument> argument_declare return_type_declare
%type <function_argument_list> argument_list_declare argument_list_declare_nonempty
%type <implementation> implementation_entry
%type <implementation_list> implementation_list
%type <lifecycle_list> lifecycle lifecycle_list

%parse-param {ParserInternalArguments& arguments}
%lex-param {ParserInternalArguments& arguments}

%initial-action {
#ifndef YYERROR_VERBOSE
  if (false) {
  yyexhaustedlab:
    YYABORT;
  }
#endif

  @$.location.file = arguments.text.location.file;
  @$.location.first_line = @$.location.last_line = arguments.text.location.first_line;
  @$.location.first_column = @$.location.last_column = arguments.text.location.first_column;
  @$.begin = @$.end = arguments.current;
}

%%

root: MODE_STATEMENT_LIST statement_list {arguments.result_statements = $2;}
| MODE_POSITIONAL_LIST expression_list {arguments.result_expressions = $2;}
| MODE_NAMESPACE namespace_list {arguments.result_statements = $2;}
| MODE_EXPRESSION expression {arguments.result_expressions.assign(1, $2);}
| MODE_FUNCTION_ARGUMENT_DECLARE argument_list_declare return_type_declare {arguments.result_argument_declarations.arguments = $2; arguments.result_argument_declarations.return_type = $3;}
| MODE_FUNCTION_ARGUMENT_IMPLICIT argument_list_declare interface_list_declare {arguments.result_argument_implicit.arguments = $2; arguments.result_argument_implicit.interfaces = $3;}
| MODE_IMPLEMENTATION_LIST implementation_list {arguments.result_implementations = $2;}
| MODE_LIFECYCLE lifecycle_list {arguments.result_lifecycle = $2;}
;

return_mode:
OPERATOR_ARROW {$$ = Psi::Compiler::result_mode_by_value;}
| OPERATOR_DASH_COLON {$$ = Psi::Compiler::result_mode_functional;}
| OPERATOR_DASH_AMP {$$ = Psi::Compiler::result_mode_lvalue;}
| OPERATOR_DASH_AMP_AMP {$$ = Psi::Compiler::result_mode_rvalue;}
;

argument_mode:
':' {$$ = Psi::Compiler::parameter_mode_input;}
| OPERATOR_COLON_RIGHT {$$ = Psi::Compiler::parameter_mode_output;}
| OPERATOR_COLON_AMP {$$ = Psi::Compiler::parameter_mode_io;}
| OPERATOR_COLON_AMP_AMP {$$ = Psi::Compiler::parameter_mode_rvalue;}
| OPERATOR_DOUBLE_COLON {$$ = Psi::Compiler::parameter_mode_functional;}
;

return_type_declare: /* blank */ {$$.reset();}
| return_mode expression {$$.reset(new FunctionArgument(@$, boost::none, $1, $2));}
;

argument_list_declare: /* blank */ {$$.clear();}
| argument_list_declare_nonempty
;

argument_list_declare_nonempty:
argument_declare {$$.assign(1, $1);}
| argument_list_declare_nonempty ',' argument_declare {$$ = $1; $$.push_back($3);}
;

argument_declare:
expression {$$.reset(new FunctionArgument(@$, boost::none, Psi::Compiler::parameter_mode_input, $1));}
| IDENTIFIER argument_mode expression {$$.reset(new FunctionArgument(@$, $1, $2, $3));}
| argument_mode expression {$$.reset(new FunctionArgument(@$, boost::none, $1, $2));}
;

interface_list_declare: /* blank */ {$$.clear();}
| interface_list_declare_nonempty
;

interface_list_declare_nonempty:
OPERATOR_ARROW expression {$$.assign(1, $2);}
| interface_list_declare_nonempty ',' expression {$$ = $1; $$.push_back($3);}
;

lifecycle_list:
lifecycle {$$.clear(); if ($1.front()) $$.push_back($1.front());}
| lifecycle_list ';' lifecycle {$$ = $1; $$.insert($$.end(), $3.begin(), $3.end());}
;

open_bracket: {PSI_ASSERT(yychar == YYEMPTY); arguments.bracket_literal = true;} '(';

lifecycle: {$$.clear();}
| IDENTIFIER open_bracket IDENTIFIER ')' BLOCK {SharedPtr<Lifecycle> c(new Lifecycle(@$, $1, $3, boost::none, $5)); $$.assign(1, c);}
| IDENTIFIER open_bracket IDENTIFIER ',' IDENTIFIER ')' BLOCK {SharedPtr<Lifecycle> c(new Lifecycle(@$, $1, $3, $5, $7)); $$.assign(1, c);}
| '!' IDENTIFIER {SharedPtr<Lifecycle> c(new Lifecycle(@$, $2, default_, default_, default_)); $$.assign(1, c);}
;

expression_list: {$$.clear();}
| expression_list_nonempty
;

expression_list_nonempty:
expression {$$.assign(1, $1);}
| expression_list_nonempty ',' expression {$$ = $1; $$.push_back($3);}
;

statement_list:
statement {$$.assign(1, $1);}
| statement_list ';' statement {$$ = $1; $$.push_back($3);}
;

statement_mode:
':' {$$ = Psi::Compiler::statement_mode_value;}
| OPERATOR_DOUBLE_COLON {$$ = Psi::Compiler::statement_mode_functional;}
| OPERATOR_COLON_AMP {$$ = Psi::Compiler::statement_mode_ref;}
;

statement:
{$$.reset();}
| expression {$$.reset(new Statement(@$, $1, boost::none, Psi::Compiler::statement_mode_destroy));}
| statement_mode expression {$$.reset(new Statement(@$, $2, boost::none, $1));}
| IDENTIFIER statement_mode expression {$$.reset(new Statement(@$, $3, $1, $2));}
;

namespace_list:
namespace_entry {$$.assign(1, $1);}
| namespace_list ';' namespace_entry {$$ = $1; $$.push_back($3);}
;

namespace_entry: {$$.reset();}
| IDENTIFIER statement_mode expression {$$.reset(new Statement(@$, $3, $1, $2));}
;

implementation_list:
implementation_entry {$$.assign(1, $1);}
| implementation_list ';' implementation_entry {$$ = $1; $$.push_back($3);}
;

implementation_entry: {$$.reset();}
| expression ':' BLOCK '=' expression {$$.reset(new Implementation(@$, false, $1, $3, $5));}
| expression ':' BLOCK BLOCK {$$.reset(new Implementation(@$, true, $1, $3, $4));}
| BLOCK {$$.reset(new Implementation(@$, true, default_, default_, $1));}
;

expression:
or_expression
| expression '=' or_expression {$$ = binary_expr(@$, @2, "__assign__", $1, $3);};
;

or_expression:
xor_expression
| or_expression '|' xor_expression {$$ = binary_expr(@$, @2, "__or__", $1, $3);}
;

xor_expression:
and_expression
| xor_expression '^' and_expression {$$ = binary_expr(@$, @2, "__xor__", $1, $3);}
;

and_expression:
compare_expression
| and_expression '&' compare_expression {$$ = binary_expr(@$, @2, "__and__", $1, $3);}
;

compare_expression:
add_expression
| compare_expression_build {$$.reset(new EvaluateExpression(@$, str_expression(@0, "__cmp__"), $1));}
;

compare_expression_build:
add_expression compare_operator add_expression {
  $$.clear();
  $$.push_back($1);
  $$.push_back(str_expression(@2, $2));
  $$.push_back($3);
}
| compare_expression_build compare_operator add_expression {
  $$ = $1;
  $$.push_back(str_expression(@2, $2));
  $$.push_back($3);
}
;

compare_operator:
COMPARE_EQUAL {$$ = "__eq__";}
| COMPARE_UNEQUAL {$$ = "__ne__";}
| COMPARE_GREATER_EQUAL {$$ = "__ge__";}
| COMPARE_LESS_EQUAL {$$ = "__le__";}
| '<' {$$ = "__lt__";}
| '>' {$$ = "__gt__";}
;

add_expression:
product_expression
| add_expression add_operator product_expression {$$ = binary_expr(@$, @2, $2, $1, $3);}
;

add_operator: '+' {$$="__add__";} | '-' {$$="__sub__";};

product_expression:
unary_expression
| product_expression product_operator unary_expression {$$ = binary_expr(@$, @2, $2, $1, $3);}
;

product_operator: '*' {$$="__mul__";} | '/' {$$="__div__";} | '%' {$$="__mod__";};

unary_expression:
macro_expression
| unary_operator unary_expression {$$ = unary_expr(@$, @1, $1, $2);}
;

unary_operator:
'-' {$$ = "__neg__";}
| '!' {$$ = "__invert__";}
;

macro_expression:
token_expression
| token_expression token_list {$$.reset(new EvaluateExpression(@$, $1, $2));}
| macro_expression '.' token_expression {$$.reset(new DotExpression(@$, $1, $3, default_));}
| macro_expression '.' token_expression token_list {$$.reset(new DotExpression(@$, $1, $3, $4));}
| macro_expression '#' {$$ = $1;}
| macro_expression '#' token_list {$$.reset(new EvaluateExpression(@$, $1, $3));}
;

token_list:
token_expression {$$.clear(); $$.push_back($1);}
| token_list token_expression {$$ = $1; $$.push_back($2);}
;

token_expression:
IDENTIFIER {$$.reset(new TokenExpression(@$, TokenExpression::identifier, $1));}
| NUMBER {$$.reset(new TokenExpression(@$, TokenExpression::number, $1));}
| BLOCK {$$ = $1;}
;

%%

namespace {
  /**
   * \brief Scanner function.
   *
   * I've done this as a handwritten function rather than using Flex
   * because bending Flex to my will seems like slightly more effort
   * than doing this. I'd like it to be able to operate on a buffer
   * without altering it, which this function does, and it takes less
   * code than Flex and the myriad of options required to make a Flex
   * scanner sensible.
   *
   * \note Note that this function lives here rather than above the
   * main parser body (where it is declared) because it required the
   * parser token definitions.
   */
  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self) {
    char c;

    if (self.mode_token != 0) {
      int result = self.mode_token;
      self.mode_token = 0;
      return result;
    }

#define SCANNER_RETURN(val) do {lvalp->text = *llocp; return (val);} while(0)
#define SCANNER_ACCEPT() (++self.current, ++llocp->end, ++llocp->location.last_column)
#define SCANNER_NEWLINE() (++llocp->location.last_line, llocp->location.last_column = 1)
    
    // Skip leading spaces and newlines
    while (true) {
      llocp->begin = llocp->end;
      llocp->location.first_line = llocp->location.last_line;
      llocp->location.first_column = llocp->location.last_column;
      PSI_ASSERT(llocp->begin == self.current);

      if (self.current == self.end)
        return 0;
      
      c = *self.current;

      if (std::strchr(" \t\r\v", c)) {
        SCANNER_ACCEPT();
      } else if (c == '\n') {
        SCANNER_ACCEPT();
        SCANNER_NEWLINE();
      } else {
        break;
      }
    }
    
    if (self.bracket_literal) {
      self.bracket_literal = false;
      if (!std::strchr("()[]{}", c))
        SCANNER_RETURN(INVALID);
      SCANNER_ACCEPT();
      SCANNER_RETURN(c);
    }

    if (c_isdigit(c)) {
      bool has_dot = false;
      SCANNER_ACCEPT();

      while (self.current != self.end) {
        c = *self.current;
        if (c == '.') {
          if (has_dot) {
            break;
          } else {
            has_dot = true;
            SCANNER_ACCEPT();
          }
        } else if (c_isalnum(c)) {
          SCANNER_ACCEPT();
        } else {
          break;
        }
      }
      SCANNER_RETURN(NUMBER);
    } else if (c_isalpha(c) || (c == '_')) {
      SCANNER_ACCEPT();
      while (self.current != self.end) {
        c = *self.current;
        if (c_isalnum(c) || (c == '_'))
          SCANNER_ACCEPT();
        else
          break;
      }
      SCANNER_RETURN(IDENTIFIER);
    } else if (std::strchr("<>=!", c)) {
      /* Multi-char comparison operators and arrow operator */
      SCANNER_ACCEPT();
      if (self.current != self.end) {
        switch (*self.current) {
        case '=':
          switch(c) {
          case '>': SCANNER_ACCEPT(); SCANNER_RETURN(COMPARE_GREATER_EQUAL);
          case '<': SCANNER_ACCEPT(); SCANNER_RETURN(COMPARE_LESS_EQUAL);
          case '=': SCANNER_ACCEPT(); SCANNER_RETURN(COMPARE_EQUAL);
          case '!': SCANNER_ACCEPT(); SCANNER_RETURN(COMPARE_UNEQUAL);
          default: break;
          }

        default:
          break;
        }
      }

      SCANNER_RETURN(c);
    } else if (c == '-') {
      SCANNER_ACCEPT();
      if (self.current != self.end) {
        switch (*self.current) {
        case '>': SCANNER_ACCEPT(); SCANNER_RETURN(OPERATOR_ARROW);
        case ':': SCANNER_ACCEPT(); SCANNER_RETURN(OPERATOR_DASH_COLON);
        case '&': {
          SCANNER_ACCEPT();
          if ((self.current != self.end) && (*self.current == '&')) {
            SCANNER_ACCEPT();
            SCANNER_RETURN(OPERATOR_DASH_AMP);
          }
          SCANNER_RETURN(OPERATOR_DASH_AMP_AMP);
        }
        
        default: break;
        }
      }
      SCANNER_RETURN('-');
    } else if (c == ':') {
      /* Variable assignment operators */
      SCANNER_ACCEPT();
      if (self.current != self.end) {
        switch (*self.current) {
        case ':': SCANNER_ACCEPT(); SCANNER_RETURN(OPERATOR_DOUBLE_COLON);
        case '>': SCANNER_ACCEPT(); SCANNER_RETURN(OPERATOR_COLON_RIGHT);
        case '&': {
          SCANNER_ACCEPT();
          if ((self.current != self.end) && (*self.current == '&')) {
            SCANNER_ACCEPT();
            SCANNER_RETURN(OPERATOR_COLON_AMP_AMP);
          }
          SCANNER_RETURN(OPERATOR_COLON_AMP);
        }
        
        default: break;
        }
      }
      SCANNER_RETURN(':');
    } else if (std::strchr(".;,+*/%^&|", c)) {
      SCANNER_ACCEPT();
      SCANNER_RETURN(c);
    } else if (std::strchr("{[(", c)) {
      int brace_depth = 0, square_bracket_depth = 0, bracket_depth = 0;
      TokenExpression::TokenType block_type;

      switch(c) {
      case '(': block_type = TokenExpression::bracket; break;
      case '[': block_type = TokenExpression::square_bracket; break;
      case '{': block_type = TokenExpression::brace; break;
      default: PSI_FAIL("should not reach this point");
      }

      while(1) {
        c = *self.current;
        SCANNER_ACCEPT();

        if (c == '\\') {
          if (self.current == self.end)
            SCANNER_RETURN(INVALID);
          if (*self.current == '\n')
            SCANNER_NEWLINE();
          SCANNER_ACCEPT();
        } else if (c == '\n') {
          SCANNER_NEWLINE();
        } else if (c == '{') {
          ++brace_depth;
        } else if (c == '}') {
          if (brace_depth == 0)
            SCANNER_RETURN(INVALID);
          --brace_depth;
        } else if (brace_depth == 0) {
          if (c == '[') {
            ++square_bracket_depth;
          } else if (c == ']') {
            if (square_bracket_depth == 0)
              SCANNER_RETURN(INVALID);
            --square_bracket_depth;
          } else if (square_bracket_depth == 0) {
            if (c == '(') {
              ++bracket_depth;
            } else if (c == ')') {
              if (bracket_depth == 0)
                SCANNER_RETURN(INVALID);
              --bracket_depth;
            }
          }
        }

        if ((bracket_depth == 0) && (square_bracket_depth == 0) && (brace_depth == 0)) {
          ParserLocation value_text(*llocp);
          ++value_text.begin;
          ++value_text.location.first_column;
          --value_text.end;
          --value_text.location.last_column;
          lvalp->token_expression.reset(new TokenExpression(*llocp, block_type, value_text));
          return BLOCK;
        } else if (self.current == self.end) {
          SCANNER_RETURN(INVALID);
        }
      }
    } else {
      SCANNER_ACCEPT();
      SCANNER_RETURN(c);
    }

#undef SCANNER_ADVANCE
  }

  void parse_helper(ParserInternalArguments& internal) {
    int result = yyparse(internal);
    if (result)
      throw ParseError(internal.error_location, internal.error_message);
  }
}

namespace Psi {
  namespace Parser {
    Element::Element(const ParserLocation& location_)
      : location(location_) {
    }

    Expression::Expression(const ParserLocation& location_, ExpressionType expression_type_)
      : Element(location_),
	expression_type(expression_type_) {
    }

    Expression::~Expression() {
    }

    TokenExpression::TokenExpression(const ParserLocation& location_, TokenType token_type_, const ParserLocation& text_)
      : Expression(location_, expression_token),
	token_type(token_type_),
	text(text_) {
    }

    TokenExpression::~TokenExpression() {
    }

    EvaluateExpression::EvaluateExpression(const ParserLocation& location_, const SharedPtr<Expression>& object_, const PSI_STD::vector<SharedPtr<Expression> >& parameters_)
      : Expression(location_, expression_evaluate), object(object_), parameters(parameters_) {
    }

    EvaluateExpression::~EvaluateExpression() {
    }

    DotExpression::DotExpression(const ParserLocation& location_, const SharedPtr<Expression>& object_,
                                 const SharedPtr<Expression>& member_, const PSI_STD::vector<SharedPtr<Expression> >& parameters_)
      : Expression(location_, expression_dot), object(object_), member(member_), parameters(parameters_) {
    }

    DotExpression::~DotExpression() {
    }

    Statement::Statement(const ParserLocation& source_, const SharedPtr<Expression>& expression_, const boost::optional<ParserLocation>& name_, int mode_)
      : Element(source_), name(name_), mode(mode_), expression(expression_) {
    }

    Statement::~Statement() {
    }
    
    Implementation::Implementation(const ParserLocation& source_, bool constructor_, const SharedPtr<Expression>& interface_, const SharedPtr<Expression>& arguments_, const SharedPtr<Expression>& value_)
    : Element(source_), constructor(constructor_), interface(interface_), arguments(arguments_), value(value_) {
    }
    
    Implementation::~Implementation() {
    }
    
    Lifecycle::Lifecycle(const ParserLocation& source_, const ParserLocation& function_name_, const ParserLocation& dest_name_,
                         const boost::optional<ParserLocation>& src_name_, const SharedPtr<TokenExpression>& body_)
    : Element(source_), function_name(function_name_), dest_name(dest_name_),
    src_name(src_name_), body(body_) {
    }
    
    Lifecycle::~Lifecycle() {
    }

    FunctionArgument::FunctionArgument(const ParserLocation& source_, const boost::optional<ParserLocation>& name_,
                                       int mode_, const SharedPtr<Expression>& type_)
    : Element(source_), name(name_), mode(mode_), type(type_) {
    }
    
    ParseError::ParseError(const PhysicalSourceLocation& location, const std::string& reason)
    : std::runtime_error(str(boost::format("%s:%d: %s") % location.file->url % location.first_line % reason)),
    m_location(location),
    m_reason(reason) {
    }

    ParseError::~ParseError() throw() {
    }

    /** \brief parse a statement list.
     * \param text Text to parse.
     */
    PSI_STD::vector<SharedPtr<Statement> > parse_statement_list(const ParserLocation& text) {
      ParserInternalArguments args(MODE_STATEMENT_LIST, text);
      parse_helper(args);
      return args.result_statements;
    }

    /** \brief parse an implementation list.
     * \param text Text to parse.
     */
    PSI_STD::vector<SharedPtr<Implementation> > parse_implementation_list(const ParserLocation& text) {
      ParserInternalArguments args(MODE_IMPLEMENTATION_LIST, text);
      parse_helper(args);
      return args.result_implementations;
    }

    /** \brief parse a lifecycle functionlist.
     * \param text Text to parse.
     */
    PSI_STD::vector<SharedPtr<Lifecycle> > parse_lifecycle_list(const ParserLocation& text) {
      ParserInternalArguments args(MODE_LIFECYCLE, text);
      parse_helper(args);
      return args.result_lifecycle;
    }

    /** \brief parse an argument list.
     * \details an argument list is a list of Expressions forming arguments to a function call.
     * \param text Text to parse.
     */
    PSI_STD::vector<SharedPtr<Statement> > parse_namespace(const ParserLocation& text) {
      ParserInternalArguments args(MODE_NAMESPACE, text);
      parse_helper(args);
      return args.result_statements;
    }

    /** \brief parse a purely positional argument list.
     * \details an argument list is a list of Expressions forming arguments to a function call.
     * \param text Text to parse.
     */
    PSI_STD::vector<SharedPtr<Expression> > parse_positional_list(const ParserLocation& text) {
      ParserInternalArguments args(MODE_POSITIONAL_LIST, text);
      parse_helper(args);
      return args.result_expressions;
    }
    
    /**
     * \brief Parse a single expression.
     */
    SharedPtr<Expression> parse_expression(const ParserLocation& text) {
      ParserInternalArguments args(MODE_EXPRESSION, text);
      parse_helper(args);
      return args.result_expressions.front();
    }

    /**
     * \brief Parse a comma-separated list of tokens.
     * 
     * A trailing comma is accepted.
     */
    PSI_STD::vector<TokenExpression> parse_identifier_list(const ParserLocation& text) {
      PSI_STD::vector<TokenExpression> result;
      
      ParserInternalArguments args(0, text);
      YYSTYPE lval;
      YYLTYPE lloc = text;
      lloc.end = lloc.begin;
      lloc.location.last_line = lloc.location.first_line;
      lloc.location.last_column = lloc.location.first_column;

      while (true) {
        int tok = yylex(&lval, &lloc, args);
        if (tok == IDENTIFIER) {
          result.push_back(TokenExpression(lloc, TokenExpression::identifier, lval.text));
        } else if (tok == 0) {
          break;
        } else if (tok != ',') {
          throw ParseError(lloc.location, "Unexpected token in identifier list");
        }
      }
      
      return result;
    }

    /** \brief parse a function argument declaration.
     * \details This is a list of argument declarations possibly
     * followed by a return type Expression.
     * \param text Text to parse.
     */
    ArgumentDeclarations parse_function_argument_declarations(const ParserLocation& text) {
      ParserInternalArguments args(MODE_FUNCTION_ARGUMENT_DECLARE, text);
      parse_helper(args);
      return args.result_argument_declarations;
    }

    /** \brief parse a function argument declaration.
     * \details This is a list of argument declarations possibly
     * followed by a return type Expression.
     * \param text Text to parse.
     */
    ImplicitArgumentDeclarations parse_function_argument_implicit_declarations(const ParserLocation& text) {
      ParserInternalArguments args(MODE_FUNCTION_ARGUMENT_IMPLICIT, text);
      parse_helper(args);
      return args.result_argument_implicit;
    }

    SharedPtr<Parser::TokenExpression> expression_as_token_type(const SharedPtr<Parser::Expression>& expr, Parser::TokenExpression::TokenType type) {
      if (expr->expression_type != Parser::expression_token)
        return SharedPtr<Parser::TokenExpression>();

      SharedPtr<Parser::TokenExpression> cast_expr = checked_pointer_cast<Parser::TokenExpression>(expr);
      if (cast_expr->token_type != type)
        return SharedPtr<Parser::TokenExpression>();

      return cast_expr;
    }
  }
}
