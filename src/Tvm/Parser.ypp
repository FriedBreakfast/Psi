/* -*- mode: c++ -*- */

%{
#include <cstring>
#include <memory>
#include <sstream>
#include <string>
#include <stdexcept>

#include <boost/assign.hpp>
#include <boost/unordered_map.hpp>

#include "Parser.hpp"
#include "Core.hpp"
#include "../Utility.hpp"
#include "../ParserUtility.hpp"
#include "../SourceLocation.hpp"

#define YYSTYPE ParserValue
#define YYLTYPE Psi::PhysicalSourceLocation

/**
 * I need to use yytype_int16 before it is defined in the generated
 * source code, so this ensures it has the same type as the one I'm
 * using.
 */
#define YYTYPE_INT16 short int

/**
 * Try to ensure that no memory is allocated on the heap by bison
 */
#define YYMALLOC(x)
#define YYFREE(x)
#define YYSTACK_USE_ALLOCA 1

#ifdef _MSC_VER
#include <malloc.h>
#define YYSTACK_ALLOC _alloca
#endif

using namespace Psi::Tvm::Parser;
using namespace Psi::Tvm::ParserUtility;

using Psi::checked_cast;
using Psi::BisonHelper;
using Psi::UniquePtr;
using Psi::Tvm::Linkage;
using Psi::Tvm::CallingConvention;
using Psi::Tvm::UniqueList;
using Psi::Tvm::ParameterAttributes;

namespace {
  struct ParserValue {
    Linkage linkage;
    CallingConvention calling_convention;
    boost::shared_ptr<UniqueList<Token> > tokens;
    boost::shared_ptr<UniqueList<Expression> > expressions;
    boost::shared_ptr<UniqueList<Block> > blocks;
    boost::shared_ptr<UniqueList<NamedExpression> > named_expressions;
    boost::shared_ptr<UniqueList<ParameterExpression> > parameter_expressions;
    boost::shared_ptr<UniqueList<GlobalElement> > globals;
    boost::shared_ptr<UniqueList<NamedGlobalElement> > named_globals;
    boost::shared_ptr<UniqueList<PhiNode> > phi_nodes;
    bool bool_value;
    ParameterAttributes attributes;
  };

  class ParserInternalArguments : public BisonHelper<YYTYPE_INT16, YYSTYPE, YYLTYPE> {
  public:
    ParserInternalArguments(const char *start_, const char *end_)
      : current(start_), end(end_) {
    }

    const char *current, *end;
    UniqueList<NamedGlobalElement> result;
    std::string error_message;
  };

  void yyerror(const YYLTYPE* loc,
               ParserInternalArguments& arguments,
               const char *s) {
    std::stringstream os;
    if (loc->first_line == loc->last_line) {
      os << loc->first_line << ':' << loc->first_column << '-' << loc->last_column;
    } else {
      os << loc->first_line << ':' << loc->first_column << '-' << loc->last_line << ':' << loc->last_column;
    }
    os << " : " << s;
    arguments.error_message = os.str();
  }

  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self);
}

#define yyoverflow(msg,yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize) arguments.overflow(yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize)
%}

%pure-parser
%locations

/* verbose errors and custom stack allocation (i.e. yyoverflow defined) will not work together in bison */
%error-verbose

%token INVALID
%token ID
%token OP
%token NUMBER
%token FUNCTION "function"
%token RECURSIVE "recursive"
%token GLOBAL "global"
%token DEFINE "define"
%token PHI "phi"
%token EXISTS "exists"
%token BLOCK "block"
%token LANDING_PAD "landing_pad"
%token EXTERN "extern"
%token CONST "const"
%token CC_C "cc_c"
%token SRET "sret"
%token LLVM_BYVAL "llvm_byval"
%token LLVM_INREG "llvm_inreg"

%token LOCAL "local"
%token PRIVATE "private"
%token ODR "odr"
%token EXPORT "export"
%token IMPORT "import"

%parse-param {ParserInternalArguments& arguments}
%lex-param {ParserInternalArguments& arguments}

%initial-action {
#ifndef YYERROR_VERBOSE
  if (false) {
  yyexhaustedlab:
    YYABORT;
  }
#endif

  @$.first_line = 1;
  @$.first_column = 1;
  @$.last_line = 1;
  @$.last_column = 1;
}

%type<tokens> ID OP
%type<expressions> NUMBER expression root_expression id_expression op_expression term_list term_list_nonempty function_type statement_expression exists_expression
%type<blocks> block_list block_list_nonempty block
%type<named_expressions> statement_list statement 
%type<parameter_expressions> parameter_list parameter_list_nonempty parameter
%type<globals> root global function constant recursive global_variable
%type<named_globals> global_list global_list_nonempty global_def
%type<phi_nodes> phi_node phi_node_list
%type<calling_convention> calling_convention
%type<bool_value> sret block_type
%type<linkage> linkage
%type<attributes> attribute attribute_list

%%

root:
global_list {arguments.result.swap(*$1);}
;

global_list: {$$ = list_empty<NamedGlobalElement>();}
| global_list_nonempty
;

global_list_nonempty:
global_def
| global_list_nonempty global_def {$$ = list_append($1, $2);}
;

global_def: ID '=' global ';' {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<GlobalElement> value(list_to_ptr($3));
  $$ = list_one<NamedGlobalElement>(new NamedGlobalElement(@$, name, value));
};

linkage: {$$=Psi::Tvm::link_private;}
| PRIVATE {$$=Psi::Tvm::link_private;}
| ODR {$$=Psi::Tvm::link_one_definition;}
| EXPORT {$$=Psi::Tvm::link_export;}
| IMPORT {$$=Psi::Tvm::link_import;}
;

global: function | constant | global_variable | recursive;

global_variable:
GLOBAL linkage expression {
  UniquePtr<Expression> type(list_to_ptr($3));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, false, $2, type));
}
| GLOBAL linkage expression expression {
  UniquePtr<Expression> type(list_to_ptr($3));
  UniquePtr<Expression> value(list_to_ptr($4));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, false, $2, type, value));
}
| GLOBAL CONST linkage expression {
  UniquePtr<Expression> type(list_to_ptr($4));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, true, $3, type));
}
| GLOBAL CONST linkage expression expression {
  UniquePtr<Expression> type(list_to_ptr($4));
  UniquePtr<Expression> value(list_to_ptr($5));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, true, $3, type, value));
}
;

constant: DEFINE root_expression {
  UniquePtr<Expression> value(list_to_ptr($2));
  $$ = list_one<GlobalElement>(new GlobalDefine(@$, value));
};

recursive:
RECURSIVE '(' parameter_list ')' '>' expression {
  UniqueList<ParameterExpression> phantom_parameters;
  UniquePtr<Expression> result(list_to_ptr($6));
  $$ = list_one<GlobalElement>(new RecursiveType(@$, phantom_parameters, *$3, result));
}
| RECURSIVE '(' parameter_list '|' parameter_list ')' '>' expression {
  UniquePtr<Expression> result(list_to_ptr($8));
  $$ = list_one<GlobalElement>(new RecursiveType(@$, *$3, *$5, result));
}
;

function:
linkage function_type {
  UniquePtr<FunctionTypeExpression> ft(checked_cast<FunctionTypeExpression*>(list_to_ptr($2)));
  $$ = list_one<GlobalElement>(new Function(@$, $1, ft));
}
| linkage function_type '{' statement_list block_list '}' {
  UniquePtr<FunctionTypeExpression> ft(checked_cast<FunctionTypeExpression*>(list_to_ptr($2)));
  UniqueList<Block> blocks;
  blocks.push_back(*new Block(@4, false, *$4));
  blocks.splice(blocks.end(), *$5);
  $$ = list_one<GlobalElement>(new Function(@$, $1, ft, blocks));
}
;

function_type:
FUNCTION calling_convention sret '(' parameter_list ')' '>' attribute_list expression {
  UniquePtr<Expression> result(list_to_ptr($9));
  UniqueList<ParameterExpression> phantom_parameters;
  $$ = list_one<Expression>(new FunctionTypeExpression(@$, $2, $3, phantom_parameters, *$5, $8, result));
}
| FUNCTION calling_convention sret '(' parameter_list '|' parameter_list ')' '>' attribute_list expression {
  UniquePtr<Expression> result(list_to_ptr($11));
  $$ = list_one<Expression>(new FunctionTypeExpression(@$, $2, $3, *$5, *$7, $10, result));
};

calling_convention: {$$=Psi::Tvm::cconv_c;} | CC_C {$$=Psi::Tvm::cconv_c;};
sret: {$$=false;} | SRET {$$=true;}

attribute_list:
{$$ = ParameterAttributes();}
| attribute_list attribute {$$ = combine_attributes($1, $2);}
;

attribute:
LLVM_BYVAL {$$ = ParameterAttributes(); $$.flags = ParameterAttributes::llvm_byval;}
| LLVM_INREG {$$ = ParameterAttributes(); $$.flags = ParameterAttributes::llvm_inreg;}
;

parameter_list: {$$ = list_empty<ParameterExpression>();} | parameter_list_nonempty

parameter_list_nonempty:
parameter
| parameter_list ',' parameter {$$ = list_append($1, $3);}
;

parameter: ID ':' attribute_list root_expression {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<Expression> type(list_to_ptr($4));
  $$ = list_one<ParameterExpression>(new ParameterExpression(@$, name, $3, type));
}
| ':' attribute_list root_expression {
  UniquePtr<Token> name;
  UniquePtr<Expression> type(list_to_ptr($3));
  $$ = list_one<ParameterExpression>(new ParameterExpression(@$, name, $2, type));
}
| root_expression {
  UniquePtr<Token> name;
  UniquePtr<Expression> type(list_to_ptr($1));
  $$ = list_one<ParameterExpression>(new ParameterExpression(@$, name, ParameterAttributes(), type));
};

block_list: {$$ = list_empty<Block>();} | block_list_nonempty

block_list_nonempty:
block
| block_list_nonempty block {$$ = list_append($1, $2);}
;

block:
block_type ID '(' ID ')' ':' statement_list {
  UniquePtr<Token> name(list_to_ptr($2));
  UniquePtr<Token> dominator_name(list_to_ptr($4));
  $$ = list_one<Block>(new Block(@$, $1, name, dominator_name, *$7));
}
| block_type ID ':' statement_list {
  UniquePtr<Token> name(list_to_ptr($2));
  UniquePtr<Token> dominator_name;
  $$ = list_one<Block>(new Block(@$, $1, name, dominator_name, *$4));
}
;

block_type: BLOCK {$$=false;} | LANDING_PAD {$$=true;};

statement_list:
statement
| statement_list statement {$$ = list_append($1, $2);}
;

statement:
statement_expression ';' {
  UniquePtr<Token> name;
  UniquePtr<Expression> value(list_to_ptr($1));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, name, value));
}
| ID '=' statement_expression ';' {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, name, value));
}
;

expression:
NUMBER
| id_expression
| op_expression
| '(' root_expression ')' {$$ = $2;}
;

statement_expression:
PHI expression ':' phi_node_list {
  UniquePtr<Expression> type(list_to_ptr($2));
  $$ = list_one<Expression>(new PhiExpression(@$, type, *$4));
}
| root_expression
;

root_expression:
'(' root_expression ')' {$$ = $2;}
| NUMBER
| id_expression
| function_type
| exists_expression
| OP term_list {
  UniquePtr<Token> op(list_to_ptr($1));
  $$ = list_one<Expression>(new CallExpression(@$, op, *$2));
}
;

id_expression: ID {
  UniquePtr<Token> name(list_to_ptr($1));
  $$ = list_one<Expression>(new NameExpression(@$, name));
};

op_expression: OP {
  UniquePtr<Token> op(list_to_ptr($1));
  UniqueList<Expression> terms;
  $$ = list_one<Expression>(new CallExpression(@$, op, terms));
};

exists_expression: EXISTS '(' parameter_list ')' '>' expression {
  UniquePtr<Expression> result(list_to_ptr($6));
  $$ = list_one<Expression>(new ExistsExpression(@$, *$3, result));
};

term_list: {$$ = list_empty<Expression>();} | term_list_nonempty;

term_list_nonempty:
expression
| term_list_nonempty expression {$$ = list_append($1, $2);}
;

phi_node_list:
phi_node
| phi_node_list ',' phi_node {$$ = list_append($1, $3);}
;

phi_node:
ID '>' expression {
  UniquePtr<Token> label(list_to_ptr($1));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<PhiNode>(new PhiNode(@$, label, value));
}
| '>' expression {
  UniquePtr<Token> label;
  UniquePtr<Expression> value(list_to_ptr($2));
  $$ = list_one<PhiNode>(new PhiNode(@$, label, value));
}
;

%%

namespace {
  const boost::unordered_map<std::string, int> keywords =
    boost::assign::map_list_of<std::string, int>
    ("block", BLOCK)
    ("const", CONST)
    ("define", DEFINE)
    ("extern", EXTERN)
    ("global", GLOBAL)
    ("function", FUNCTION)
    ("phi", PHI)
    ("recursive", RECURSIVE)
    ("exists", EXISTS)
    ("sret", SRET)
    ("llvm_byval", LLVM_BYVAL)
    ("llvm_inreg", LLVM_INREG)
    ("cc_c", CC_C)
    ("local", LOCAL)
    ("private", PRIVATE)
    ("odr", ODR)
    ("export", EXPORT)
    ("import", IMPORT);

  const boost::unordered_map<char, LiteralType> signed_literals =
    boost::assign::map_list_of<char, LiteralType>
    ('b', literal_byte)
    ('s', literal_short)
    ('i', literal_int)
    ('l', literal_long)
    ('q', literal_quad)
    ('p', literal_intptr);

  const boost::unordered_map<char, LiteralType> unsigned_literals =
    boost::assign::map_list_of<char, LiteralType>
    ('b', literal_ubyte)
    ('s', literal_ushort)
    ('i', literal_uint)
    ('l', literal_ulong)
    ('q', literal_uquad)
    ('p', literal_uintptr);

  /**
   * \brief Scanner function.
   *
   * I've done this as a handwritten function rather than using Flex
   * because bending Flex to my will seems like slightly more effort
   * than doing this. I'd like it to be able to operate on a buffer
   * without altering it, which this function does, and it takes less
   * code than Flex and the myriad of options required to make a Flex
   * scanner sensible.
   *
   * \note Note that this function lives here rather than above the
   * main parser body (where it is declared) because it required the
   * parser token definitions.
   */
  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self) {
#define SCANNER_ACCEPT() (++self.current, ++llocp->last_column)

    while(self.current != self.end) {
      if (std::strchr(" \t\r\v", *self.current)) {
        SCANNER_ACCEPT();
      } else if (*self.current == '\n') {
        ++llocp->last_line;
        llocp->last_column = 1;
        SCANNER_ACCEPT();
      } else {
        break;
      }
    }

    if (self.current == self.end)
      return 0;

    llocp->first_line = llocp->last_line;
    llocp->first_column = llocp->last_column;

    int token_type;

    switch(*self.current) {
    case '#':
      token_type = NUMBER;
      SCANNER_ACCEPT();
      break;

    case '%':
      token_type = ID;
      SCANNER_ACCEPT();
      break;

    default:
      PSI_ASSERT(*self.current != '%');
      if (token_char(*self.current)) {
        token_type = OP;
        break;
      } else {
        char c = *self.current;
        SCANNER_ACCEPT();
        return c;
      }
    }

    const char *start = self.current;

    while ((self.current != self.end) && token_char(*self.current))
      SCANNER_ACCEPT();

    const char *end = self.current;

    if (start == end)
      return INVALID;

    std::string text;
    for (const char *p = start; p != end; ++p) {
      if (*p != '%') {
        text.push_back(*p);
      } else {
        int c = 0;
        ++p;
        if (p != end) {
          c = *p - '0';
          ++p;
          if (p != end) {
            c <<= 8;
            c |= *p - '0';
          }
        }
        text.push_back(c);
      }
    }

    if (token_type == OP) {
      boost::unordered_map<std::string, int>::const_iterator it = keywords.find(text);
      if (it != keywords.end())
        return it->second;
    } else if (token_type == NUMBER) {
      if (text.size() < 2)
        return INVALID;

      boost::unordered_map<char, LiteralType>::const_iterator it;
      std::string literal_text;
      Psi::PhysicalSourceLocation literal_loc(*llocp);
      if (text[0] == 'u') {
        it = unsigned_literals.find(text[1]);
        if (it == unsigned_literals.end())
          return INVALID;
        literal_loc.first_column += 2;
        literal_text = text.substr(2);
      } else {
        it = signed_literals.find(text[0]);
        if (it == signed_literals.end())
          return INVALID;
        literal_loc.first_column += 1;
        literal_text = text.substr(1);
      }

      UniquePtr<Token> literal_token(new Token(literal_loc, literal_text));

      lvalp->expressions = list_one<Expression>(new LiteralExpression(*llocp, it->second, literal_token));
    }

    lvalp->tokens = list_one<Token>(new Token(*llocp, text));
    return token_type;

#undef SCANNER_ADVANCE
  }
}

namespace Psi {
  namespace Tvm {
    namespace Parser {
      Element::Element(const PhysicalSourceLocation& location_) : location(location_) {
      }

      Token::Token(const PhysicalSourceLocation& location_, const std::string& text_)
        : Element(location_), text(text_) {
      }

      Expression::Expression(const PhysicalSourceLocation& location_, ExpressionType expression_type_)
        : Element(location_), expression_type(expression_type_) {
      }

      Expression::~Expression() {
      }

      NameExpression::NameExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_)
        : Expression(location_, expression_name) {
        name.swap(name_);
      }

      PhiNode::PhiNode(const PhysicalSourceLocation& location_, UniquePtr<Token>& label_, UniquePtr<Expression>& expression_)
        : Element(location_) {
        label.swap(label_);
        expression.swap(expression_);
      }

      PhiExpression::PhiExpression(const PhysicalSourceLocation& location_, UniquePtr<Expression>& type_, UniqueList<PhiNode>& nodes_)
        : Expression(location_, expression_phi) {
        type.swap(type_);
        nodes.swap(nodes_);
      }

      CallExpression::CallExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& target_,
                                     UniqueList<Expression>& terms_)
        : Expression(location_, expression_call) {
        target.swap(target_);
        terms.swap(terms_);
      }

      FunctionTypeExpression::FunctionTypeExpression(const PhysicalSourceLocation& location_,
                                                     CallingConvention calling_convention_,
                                                     bool sret_,
                                                     UniqueList<ParameterExpression>& phantom_parameters_,
                                                     UniqueList<ParameterExpression>& parameters_,
                                                     ParameterAttributes result_attributes_,
                                                     UniquePtr<Expression>& result_type_)
        : Expression(location_, expression_function_type),
          calling_convention(calling_convention_),
          sret(sret_),
          result_attributes(result_attributes_) {
        phantom_parameters.swap(phantom_parameters_);
        parameters.swap(parameters_);
        result_type.swap(result_type_);
      }
      
      ExistsExpression::ExistsExpression(const PhysicalSourceLocation& location_,
                                         UniqueList<ParameterExpression>& parameters_,
                                         UniquePtr<Expression>& result_)
      : Expression(location_, expression_exists) {
        parameters.swap(parameters_);
        result.swap(result_);
      }

      LiteralExpression::LiteralExpression(const PhysicalSourceLocation& location_, LiteralType literal_type_, UniquePtr<Token>& value_)
        : Expression(location_, expression_literal),
          literal_type(literal_type_) {
        value.swap(value_);
      }

      NamedExpression::NamedExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_, UniquePtr<Expression>& expression_)
        : Element(location_) {
        name.swap(name_);
        expression.swap(expression_);
      }
      
      ParameterExpression::ParameterExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_,
                                               ParameterAttributes attributes_, UniquePtr<Expression>& expression_)
        : NamedExpression(location_, name_, expression_), attributes(attributes_) {
      }

      Block::Block(const PhysicalSourceLocation& location_, bool landing_pad_, UniquePtr<Token>& name_,
                   UniquePtr<Token>& dominator_name_,
                   UniqueList<NamedExpression>& statements_)
        : Element(location_),
        landing_pad(landing_pad_) {
        name.swap(name_);
        dominator_name.swap(dominator_name_);
        statements.swap(statements_);
      }

      Block::Block(const PhysicalSourceLocation& location_, bool landing_pad_,
                   UniqueList<NamedExpression>& statements_)
        : Element(location_),
        landing_pad(landing_pad_) {
        statements.swap(statements_);
      }

      GlobalElement::GlobalElement(const PhysicalSourceLocation& location_, GlobalType global_type_)
        : Element(location_), global_type(global_type_) {
      }

      GlobalElement::~GlobalElement() {
      }

      Function::Function(const PhysicalSourceLocation& location_,
                         Linkage linkage_,
                         UniquePtr<FunctionTypeExpression>& type_)
        : GlobalElement(location_, global_function),
        linkage(linkage_) {
        type.swap(type_);
      }

      Function::Function(const PhysicalSourceLocation& location_,
                         Linkage linkage_,
                         UniquePtr<FunctionTypeExpression>& type_,
                         UniqueList<Block>& blocks_)
        : GlobalElement(location_, global_function),
        linkage(linkage_) {
        type.swap(type_);
        blocks.swap(blocks_);
      }

      GlobalVariable::GlobalVariable(const PhysicalSourceLocation& location_,
                                     bool constant_,
                                     Linkage linkage_,
                                     UniquePtr<Expression>& type_)
        : GlobalElement(location_, global_variable),
          constant(constant_),
          linkage(linkage_) {
        type.swap(type_);
      }

      GlobalVariable::GlobalVariable(const PhysicalSourceLocation& location_,
                                     bool constant_,
                                     Linkage linkage_,
                                     UniquePtr<Expression>& type_,
                                     UniquePtr<Expression>& value_)
        : GlobalElement(location_, global_variable),
          constant(constant_),
          linkage(linkage_) {
        type.swap(type_);
        value.swap(value_);
      }

      GlobalDefine::GlobalDefine(const PhysicalSourceLocation& location_,
                     UniquePtr<Expression>& value_)
        : GlobalElement(location_, global_define) {
        value.swap(value_);
      }
      
      RecursiveType::RecursiveType(const PhysicalSourceLocation& location_,
                                   UniqueList<ParameterExpression>& phantom_parameters_,
                                   UniqueList<ParameterExpression>& parameters_,
                                   UniquePtr<Expression>& result_)
      : GlobalElement(location_, global_recursive) {
        phantom_parameters.swap(phantom_parameters_);
        parameters.swap(parameters_);
        result.swap(result_);
      }

      NamedGlobalElement::NamedGlobalElement(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_, UniquePtr<GlobalElement>& value_)
        : Element(location_) {
        name.swap(name_);
        value.swap(value_);
      }
    }

    void parse(UniqueList<NamedGlobalElement>& result, const char *begin, const char *end) {
      ParserInternalArguments ia(begin, end);
      yyparse(ia);
      if (!ia.error_message.empty()) {
        throw std::logic_error(ia.error_message);
      } else {
        result.swap(ia.result);
      }
    }

    void parse(UniqueList<NamedGlobalElement>& result, const char *begin) {
      parse(result, begin, begin+std::strlen(begin));
    }
  }
}
