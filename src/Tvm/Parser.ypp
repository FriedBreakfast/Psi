/* -*- mode: c++ -*- */

%{
#include <cstring>
#include <memory>
#include <sstream>
#include <string>
#include <stdexcept>

#include <boost/assign.hpp>
#include <boost/unordered_map.hpp>

#include "Parser.hpp"
#include "Core.hpp"
#include "../Utility.hpp"
#include "../ParserUtility.hpp"
#include "../SourceLocation.hpp"

#define YYSTYPE ParserValue
#define YYLTYPE Psi::PhysicalSourceLocation

/**
 * I need to use yytype_int16 before it is defined in the generated
 * source code, so this ensures it has the same type as the one I'm
 * using.
 */
#define YYTYPE_INT16 short int

/**
 * Try to ensure that no memory is allocated on the heap by bison
 */
#define YYMALLOC(x)
#define YYFREE(x)
#define YYSTACK_USE_ALLOCA 1

using namespace Psi;
using namespace Psi::Tvm;
using namespace Psi::Tvm::Parser;
using namespace Psi::Tvm::ParserUtility;

namespace {
  struct ParserValue {
    CallingConvention calling_convention;
    boost::shared_ptr<UniqueList<Token> > tokens;
    boost::shared_ptr<UniqueList<Expression> > expressions;
    boost::shared_ptr<UniqueList<Block> > blocks;
    boost::shared_ptr<UniqueList<NamedExpression> > named_expressions;
    boost::shared_ptr<UniqueList<GlobalElement> > globals;
    boost::shared_ptr<UniqueList<NamedGlobalElement> > named_globals;
    boost::shared_ptr<UniqueList<PhiNode> > phi_nodes;
    bool bool_value;
  };

  class ParserInternalArguments : public BisonHelper<YYTYPE_INT16, YYSTYPE, YYLTYPE> {
  public:
    ParserInternalArguments(const char *start_, const char *end_)
      : current(start_), end(end_) {
    }

    const char *current, *end;
    UniqueList<NamedGlobalElement> result;
    std::string error_message;
  };

  void yyerror(const YYLTYPE* loc,
               ParserInternalArguments& arguments,
               const char *s) {
    std::stringstream os;
    if (loc->first_line == loc->last_line) {
      os << loc->first_line << ':' << loc->first_column << '-' << loc->last_column;
    } else {
      os << loc->first_line << ':' << loc->first_column << '-' << loc->last_line << ':' << loc->last_column;
    }
    os << " : " << s;
    arguments.error_message = os.str();
  }

  /**
   * \brief Checks if a character is a "token" character.
   *
   * A token character is alphanumeric or underscore, so this is
   * equivalent the following in the C locale:
   *
   * \code isalpha(c) || isdigit(c) || c == '_' \endcode
   */
  bool token_char(char c) {
    return ((c >= 'A') && (c <= 'Z')) ||
      ((c >= 'a') && (c <= 'z')) ||
      ((c >= '0') && (c <= '9')) ||
      (c == '_') ||
      (c == '-');
  }

  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self);
}

#define yyoverflow(msg,yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize) arguments.overflow(yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize)
%}

%pure-parser
%locations

/* verbose errors and custom stack allocation (i.e. yyoverflow defined) will not work together in bison */
%error-verbose

%token INVALID
%token ID
%token OP
%token NUMBER
%token FUNCTION "function"
%token GLOBAL "global"
%token DEFINE "define"
%token PHI "phi"
%token BLOCK "block"
%token LANDING_PAD "landing_pad"
%token EXTERN "extern"
%token CONST "const"
%token CC_C "cc_c"

%parse-param {ParserInternalArguments& arguments}
%lex-param {ParserInternalArguments& arguments}

%initial-action {
#ifndef YYERROR_VERBOSE
  if (false) {
  yyexhaustedlab:
    YYABORT;
  }
#endif

  @$.first_line = 1;
  @$.first_column = 1;
  @$.last_line = 1;
  @$.last_column = 1;
}

%type<tokens> ID OP
%type<expressions> NUMBER expression root_expression id_expression op_expression bracket_expression term_list term_list_nonempty function_type statement_expression
%type<blocks> block_list block_list_nonempty block
%type<named_expressions> statement_list statement parameter_list parameter_list_nonempty parameter
%type<globals> root global function constant global_variable
%type<named_globals> global_list global_list_nonempty global_def
%type<phi_nodes> phi_node phi_node_list
%type<calling_convention> calling_convention
%type<bool_value> block_type

%%

root:
global_list {arguments.result.swap(*$1);}
;

global_list: {$$ = list_empty<NamedGlobalElement>();}
| global_list_nonempty
;

global_list_nonempty:
global_def
| global_list_nonempty global_def {$$ = list_append($1, $2);}
;

global_def: ID '=' linkage global ';' {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<GlobalElement> value(list_to_ptr($4));
  $$ = list_one<NamedGlobalElement>(new NamedGlobalElement(@$, name, value));
};

linkage:
| EXTERN
;

global: function | constant | global_variable;

global_variable:
GLOBAL expression {
  UniquePtr<Expression> type(list_to_ptr($2));
  $$ = list_one<GlobalElement>(new Parser::GlobalVariable(@$, false, type));
}
| GLOBAL expression expression {
  UniquePtr<Expression> type(list_to_ptr($2));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<GlobalElement>(new Parser::GlobalVariable(@$, false, type, value));
}
| GLOBAL CONST expression {
  UniquePtr<Expression> type(list_to_ptr($3));
  $$ = list_one<GlobalElement>(new Parser::GlobalVariable(@$, true, type));
}
| GLOBAL CONST expression expression {
  UniquePtr<Expression> type(list_to_ptr($3));
  UniquePtr<Expression> value(list_to_ptr($4));
  $$ = list_one<GlobalElement>(new Parser::GlobalVariable(@$, true, type, value));
}
;

constant: DEFINE root_expression {
  UniquePtr<Expression> value(list_to_ptr($2));
  $$ = list_one<GlobalElement>(new GlobalDefine(@$, value));
};

function:
function_type {
  UniquePtr<FunctionTypeExpression> ft(checked_cast<FunctionTypeExpression*>(list_to_ptr($1)));
  $$ = list_one<GlobalElement>(new Parser::Function(@$, ft));
}
| function_type '{' statement_list block_list '}' {
  UniquePtr<FunctionTypeExpression> ft(checked_cast<FunctionTypeExpression*>(list_to_ptr($1)));
  UniqueList<Block> blocks;
  blocks.push_back(*new Block(@3, false, *$3));
  blocks.splice(blocks.end(), *$4);
  $$ = list_one<GlobalElement>(new Parser::Function(@$, ft, blocks));
}
;

function_type:
FUNCTION calling_convention '(' parameter_list ')' '>' expression {
  UniquePtr<Expression> result(list_to_ptr($7));
  UniqueList<NamedExpression> phantom_parameters;
  $$ = list_one<Expression>(new FunctionTypeExpression(@$, $2, phantom_parameters, *$4, result));
}
| FUNCTION calling_convention '(' parameter_list '|' parameter_list ')' '>' expression {
  UniquePtr<Expression> result(list_to_ptr($9));
  $$ = list_one<Expression>(new FunctionTypeExpression(@$, $2, *$4, *$6, result));
};

calling_convention: {$$=cconv_c;} | CC_C {$$=cconv_c;};

parameter_list: {$$ = list_empty<NamedExpression>();} | parameter_list_nonempty

parameter_list_nonempty:
parameter
| parameter_list ',' parameter {$$ = list_append($1, $3);}
;

parameter: ID ':' root_expression {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<Expression> type(list_to_ptr($3));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, name, type));
}
| root_expression {
  UniquePtr<Expression> type(list_to_ptr($1));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, type));
};

block_list: {$$ = list_empty<Block>();} | block_list_nonempty

block_list_nonempty:
block
| block_list_nonempty block {$$ = list_append($1, $2);}
;

block:
block_type ID '(' ID ')' ':' statement_list {
  UniquePtr<Token> name(list_to_ptr($2));
  UniquePtr<Token> dominator_name(list_to_ptr($4));
  $$ = list_one<Block>(new Block(@$, $1, name, dominator_name, *$7));
}
| block_type ID ':' statement_list {
  UniquePtr<Token> name(list_to_ptr($2));
  UniquePtr<Token> dominator_name;
  $$ = list_one<Block>(new Block(@$, $1, name, dominator_name, *$4));
}
;

block_type: BLOCK {$$=false;} | LANDING_PAD {$$=true;};

statement_list:
statement
| statement_list statement {$$ = list_append($1, $2);}
;

statement:
statement_expression ';' {
  UniquePtr<Expression> value(list_to_ptr($1));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, value));
}
| ID '=' statement_expression ';' {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, name, value));
}
;

expression:
NUMBER
| id_expression
| op_expression
| '(' root_expression ')' {$$ = $2;}
;

statement_expression:
PHI expression ':' phi_node_list {
  UniquePtr<Expression> type(list_to_ptr($2));
  $$ = list_one<Expression>(new PhiExpression(@$, type, *$4));
}
| root_expression
;

root_expression:
NUMBER
| id_expression
| bracket_expression
| function_type
| '(' root_expression ')' {$$ = $2;}
;

id_expression: ID {
  UniquePtr<Token> name(list_to_ptr($1));
  $$ = list_one<Expression>(new NameExpression(@$, name));
};

op_expression: OP {
  UniquePtr<Token> op(list_to_ptr($1));
  UniqueList<Expression> terms;
  $$ = list_one<Expression>(new CallExpression(@$, op, terms));
};

bracket_expression:
OP term_list {
  UniquePtr<Token> op(list_to_ptr($1));
  $$ = list_one<Expression>(new CallExpression(@$, op, *$2));
}
| function_type
;

term_list: {$$ = list_empty<Expression>();} | term_list_nonempty;

term_list_nonempty:
expression
| term_list_nonempty expression {$$ = list_append($1, $2);}
;

phi_node_list:
phi_node
| phi_node_list ',' phi_node {$$ = list_append($1, $3);}
;

phi_node:
ID '>' expression {
  UniquePtr<Token> label(list_to_ptr($1));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<PhiNode>(new PhiNode(@$, label, value));
}
;

%%

namespace {
  const boost::unordered_map<std::string, int> keywords =
    boost::assign::map_list_of<std::string, int>
    ("block", BLOCK)
    ("const", CONST)
    ("define", DEFINE)
    ("extern", EXTERN)
    ("global", GLOBAL)
    ("function", FUNCTION)
    ("phi", PHI)
    ("cc_c", CC_C);

  const boost::unordered_map<char, LiteralType> signed_literals =
    boost::assign::map_list_of<char, LiteralType>
    ('b', literal_byte)
    ('s', literal_short)
    ('i', literal_int)
    ('l', literal_long)
    ('q', literal_quad)
    ('p', literal_intptr);

  const boost::unordered_map<char, LiteralType> unsigned_literals =
    boost::assign::map_list_of<char, LiteralType>
    ('b', literal_ubyte)
    ('s', literal_ushort)
    ('i', literal_uint)
    ('l', literal_ulong)
    ('q', literal_uquad)
    ('p', literal_uintptr);

  /**
   * \brief Scanner function.
   *
   * I've done this as a handwritten function rather than using Flex
   * because bending Flex to my will seems like slightly more effort
   * than doing this. I'd like it to be able to operate on a buffer
   * without altering it, which this function does, and it takes less
   * code than Flex and the myriad of options required to make a Flex
   * scanner sensible.
   *
   * \note Note that this function lives here rather than above the
   * main parser body (where it is declared) because it required the
   * parser token definitions.
   */
  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self) {
#define SCANNER_ACCEPT() (++self.current, ++llocp->last_column)

    while(self.current != self.end) {
      if (std::strchr(" \t\r\v", *self.current)) {
        SCANNER_ACCEPT();
      } else if (*self.current == '\n') {
        ++llocp->last_line;
        llocp->last_column = 1;
        SCANNER_ACCEPT();
      } else {
        break;
      }
    }

    if (self.current == self.end)
      return 0;

    llocp->first_line = llocp->last_line;
    llocp->first_column = llocp->last_column;

    int token_type;

    switch(*self.current) {
    case '#':
      token_type = NUMBER;
      SCANNER_ACCEPT();
      break;

    case '%':
      token_type = ID;
      SCANNER_ACCEPT();
      break;

    default:
      if (token_char(*self.current)) {
        token_type = OP;
        break;
      } else {
        char c = *self.current;
        SCANNER_ACCEPT();
        return c;
      }
    }

    const char *start = self.current;

    while ((self.current != self.end) && token_char(*self.current))
      SCANNER_ACCEPT();

    const char *end = self.current;

    if (start == end)
      return INVALID;

    std::string text(start, end);

    if (token_type == OP) {
      boost::unordered_map<std::string, int>::const_iterator it = keywords.find(text);
      if (it != keywords.end())
        return it->second;
    } else if (token_type == NUMBER) {
      if (text.size() < 2)
        return INVALID;

      boost::unordered_map<char, LiteralType>::const_iterator it;
      std::string literal_text;
      PhysicalSourceLocation literal_loc(*llocp);
      if (text[0] == 'u') {
        it = unsigned_literals.find(text[1]);
        if (it == unsigned_literals.end())
          return INVALID;
        literal_loc.first_column += 2;
        literal_text = text.substr(2);
      } else {
        it = signed_literals.find(text[0]);
        if (it == signed_literals.end())
          return INVALID;
        literal_loc.first_column += 1;
        literal_text = text.substr(1);
      }

      UniquePtr<Token> literal_token(new Token(literal_loc, literal_text));

      lvalp->expressions = list_one<Expression>(new LiteralExpression(*llocp, it->second, literal_token));
    }

    lvalp->tokens = list_one<Token>(new Token(*llocp, text));
    return token_type;

#undef SCANNER_ADVANCE
  }
}

namespace Psi {
  namespace Tvm {
    namespace Parser {
      Element::Element(const PhysicalSourceLocation& location_) : location(location_) {
      }

      Token::Token(const PhysicalSourceLocation& location_, const std::string& text_)
        : Element(location_), text(text_) {
      }

      Expression::Expression(const PhysicalSourceLocation& location_, ExpressionType expression_type_)
        : Element(location_), expression_type(expression_type_) {
      }

      Expression::~Expression() {
      }

      NameExpression::NameExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_)
        : Expression(location_, expression_name) {
        name.swap(name_);
      }

      NameExpression::~NameExpression() {
      }

      PhiNode::PhiNode(const PhysicalSourceLocation& location_, UniquePtr<Token>& label_, UniquePtr<Expression>& expression_)
        : Element(location_) {
        label.swap(label_);
        expression.swap(expression_);
      }

      PhiNode::~PhiNode() {
      }

      PhiExpression::PhiExpression(const PhysicalSourceLocation& location_, UniquePtr<Expression>& type_, UniqueList<PhiNode>& nodes_)
        : Expression(location_, expression_phi) {
        type.swap(type_);
        nodes.swap(nodes_);
      }

      PhiExpression::~PhiExpression() {
      }

      CallExpression::CallExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& target_,
                                     UniqueList<Expression>& terms_)
        : Expression(location_, expression_call) {
        target.swap(target_);
        terms.swap(terms_);
      }

      CallExpression::~CallExpression() {
      }

      FunctionTypeExpression::FunctionTypeExpression(const PhysicalSourceLocation& location_,
                                                     CallingConvention calling_convention_,
                                                     UniqueList<NamedExpression>& phantom_parameters_,
                                                     UniqueList<NamedExpression>& parameters_,
                                                     UniquePtr<Expression>& result_type_)
        : Expression(location_, expression_function_type),
          calling_convention(calling_convention_) {
        phantom_parameters.swap(phantom_parameters_);
        parameters.swap(parameters_);
        result_type.swap(result_type_);
      }

      FunctionTypeExpression::~FunctionTypeExpression() {
      }

      LiteralExpression::LiteralExpression(const PhysicalSourceLocation& location_, LiteralType literal_type_, UniquePtr<Token>& value_)
        : Expression(location_, expression_literal),
          literal_type(literal_type_) {
        value.swap(value_);
      }

      LiteralExpression::~LiteralExpression() {
      }

      NamedExpression::NamedExpression(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_, UniquePtr<Expression>& expression_)
        : Element(location_) {
        name.swap(name_);
        expression.swap(expression_);
      }

      NamedExpression::NamedExpression(const PhysicalSourceLocation& location_, UniquePtr<Expression>& expression_)
        : Element(location_) {
        expression.swap(expression_);
      }

      NamedExpression::~NamedExpression() {
      }

      Block::Block(const PhysicalSourceLocation& location_, bool landing_pad_, UniquePtr<Token>& name_,
                   UniquePtr<Token>& dominator_name_,
                   UniqueList<NamedExpression>& statements_)
        : Element(location_),
        landing_pad(landing_pad_) {
        name.swap(name_);
        dominator_name.swap(dominator_name_);
        statements.swap(statements_);
      }

      Block::Block(const PhysicalSourceLocation& location_, bool landing_pad_,
                   UniqueList<NamedExpression>& statements_)
        : Element(location_),
        landing_pad(landing_pad_) {
        statements.swap(statements_);
      }

      Block::~Block() {
      }

      GlobalElement::GlobalElement(const PhysicalSourceLocation& location_, GlobalType global_type_)
        : Element(location_), global_type(global_type_) {
      }

      GlobalElement::~GlobalElement() {
      }

      Function::Function(const PhysicalSourceLocation& location_,
                         UniquePtr<FunctionTypeExpression>& type_)
        : GlobalElement(location_, global_function) {
        type.swap(type_);
      }

      Function::Function(const PhysicalSourceLocation& location_,
                         UniquePtr<FunctionTypeExpression>& type_,
                         UniqueList<Block>& blocks_)
        : GlobalElement(location_, global_function) {
        type.swap(type_);
        blocks.swap(blocks_);
      }

      Function::~Function() {
      }

      GlobalVariable::GlobalVariable(const PhysicalSourceLocation& location_,
                                     bool constant_,
                                     UniquePtr<Expression>& type_)
        : GlobalElement(location_, global_variable),
          constant(constant_) {
        type.swap(type_);
      }

      GlobalVariable::GlobalVariable(const PhysicalSourceLocation& location_,
                                     bool constant_,
                                     UniquePtr<Expression>& type_,
                                     UniquePtr<Expression>& value_)
        : GlobalElement(location_, global_variable),
          constant(constant_) {
        type.swap(type_);
        value.swap(value_);
      }

      GlobalVariable::~GlobalVariable() {
      }

      GlobalDefine::GlobalDefine(const PhysicalSourceLocation& location_,
                     UniquePtr<Expression>& value_)
        : GlobalElement(location_, global_define) {
        value.swap(value_);
      }

      GlobalDefine::~GlobalDefine() {
      }

      NamedGlobalElement::NamedGlobalElement(const PhysicalSourceLocation& location_, UniquePtr<Token>& name_, UniquePtr<GlobalElement>& value_)
        : Element(location_) {
        name.swap(name_);
        value.swap(value_);
      }

      NamedGlobalElement::~NamedGlobalElement() {
      }
    }

    void parse(UniqueList<Parser::NamedGlobalElement>& result, const char *begin, const char *end) {
      ParserInternalArguments ia(begin, end);
      yyparse(ia);
      if (!ia.error_message.empty()) {
        throw std::logic_error(ia.error_message);
      } else {
        result.swap(ia.result);
      }
    }

    void parse(UniqueList<Parser::NamedGlobalElement>& result, const char *begin) {
      parse(result, begin, begin+std::strlen(begin));
    }
  }
}
