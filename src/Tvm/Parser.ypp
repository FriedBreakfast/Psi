/* -*- mode: c++ -*- */

%{
#include <cstring>
#include <memory>
#include <sstream>
#include <string>
#include <stdexcept>
#include <tr1/unordered_map>

#include <boost/assign.hpp>

#include "Parser.hpp"
#include "Core.hpp"
#include "../Utility.hpp"
#include "../ParserUtility.hpp"

#define YYSTYPE Value
#define YYLTYPE Psi::Tvm::Parser::Location

/**
 * I need to use yytype_int16 before it is defined in the generated
 * source code, so this ensures it has the same type as the one I'm
 * using.
 */
#define YYTYPE_INT16 short int

/**
 * Try to ensure that no memory is allocated on the heap by bison
 */
#define YYMALLOC(x)
#define YYFREE(x)
#define YYSTACK_USE_ALLOCA 1

using namespace Psi;
using namespace Psi::ParserUtility;
using namespace Psi::Tvm;
using namespace Psi::Tvm::Parser;

namespace {
  struct Value {
    CallingConvention calling_convention;
    boost::shared_ptr<UniqueList<Token> > tokens;
    boost::shared_ptr<UniqueList<Expression> > expressions;
    boost::shared_ptr<UniqueList<Block> > blocks;
    boost::shared_ptr<UniqueList<NamedExpression> > named_expressions;
    boost::shared_ptr<UniqueList<GlobalElement> > globals;
    boost::shared_ptr<UniqueList<NamedGlobalElement> > named_globals;
    boost::shared_ptr<UniqueList<PhiNode> > phi_nodes;
  };

  class ParserInternalArguments : public BisonHelper<YYTYPE_INT16, YYSTYPE, YYLTYPE> {
  public:
    ParserInternalArguments(const char *start_, const char *end_)
      : current(start_), end(end_) {
    }

    const char *current, *end;
    UniqueList<NamedGlobalElement> result;
    std::string error_message;
  };

  void yyerror(const YYLTYPE* loc,
               ParserInternalArguments& arguments,
               const char *s) {
    std::stringstream os;
    if (loc->first_line == loc->last_line) {
      os << loc->first_line << ':' << loc->first_column << '-' << loc->last_column;
    } else {
      os << loc->first_line << ':' << loc->first_column << '-' << loc->last_line << ':' << loc->last_column;
    }
    os << " : " << s;
    arguments.error_message = os.str();
  }

  /**
   * \brief Checks if a character is a "token" character.
   *
   * A token character is alphanumeric or underscore, so this is
   * equivalent the following in the C locale:
   *
   * \code isalpha(c) || isdigit(c) || c == '_' \endcode
   */
  bool token_char(char c) {
    return ((c >= 'A') && (c <= 'Z')) ||
      ((c >= 'a') && (c <= 'z')) ||
      ((c >= '0') && (c <= '9')) ||
      (c == '_');
  }

  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self);
}

#define yyoverflow(msg,yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize) arguments.overflow(yysp,yyssize,yyvp,yyvsize,yylp,yylsize,yystacksize)
%}

%pure-parser
%locations

/* verbose errors and custom stack allocation (i.e. yyoverflow defined) will not work together in bison */
%error-verbose

%token INVALID
%token ID
%token OP
%token NUMBER
%token FUNCTION "function"
%token GLOBAL "global"
%token DEFINE "define"
%token PHI "phi"
%token BLOCK "block"
%token EXTERN "extern"
%token CONST "const"
%token CC_TVM "cc_tvm"
%token CC_C "cc_c"

%parse-param {ParserInternalArguments& arguments}
%lex-param {ParserInternalArguments& arguments}

%initial-action {
#ifndef YYERROR_VERBOSE
  if (false) {
  yyexhaustedlab:
    YYABORT;
  }
#endif

  @$.first_line = 1;
  @$.first_column = 1;
  @$.last_line = 1;
  @$.last_column = 1;
}

%type<tokens> ID OP
%type<expressions> NUMBER expression root_expression id_expression op_expression bracket_expression term_list term_list_nonempty function_type
%type<blocks> block_list block_list_nonempty block
%type<named_expressions> statement_list statement parameter_list parameter_list_nonempty parameter
%type<globals> root global function constant global_variable
%type<named_globals> global_list global_list_nonempty global_def
%type<phi_nodes> phi_node phi_node_list
%type<calling_convention> calling_convention

%%

root:
global_list {arguments.result.swap(*$1);}
;

global_list: {$$ = list_empty<NamedGlobalElement>();}
| global_list_nonempty
;

global_list_nonempty:
global_def
| global_list_nonempty global_def {$$ = list_append($1, $2);}
;

global_def: ID '=' linkage global ';' {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<GlobalElement> value(list_to_ptr($4));
  $$ = list_one<NamedGlobalElement>(new NamedGlobalElement(@$, name, value));
};

linkage:
| EXTERN
;

global: function | constant | global_variable;

global_variable:
GLOBAL expression {
  UniquePtr<Expression> type(list_to_ptr($2));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, false, type));
}
| GLOBAL expression expression {
  UniquePtr<Expression> type(list_to_ptr($2));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, false, type, value));
}
| GLOBAL CONST expression {
  UniquePtr<Expression> type(list_to_ptr($3));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, true, type));
}
| GLOBAL CONST expression expression {
  UniquePtr<Expression> type(list_to_ptr($3));
  UniquePtr<Expression> value(list_to_ptr($4));
  $$ = list_one<GlobalElement>(new GlobalVariable(@$, true, type, value));
}
;

constant: DEFINE expression {
  UniquePtr<Expression> value(list_to_ptr($2));
  $$ = list_one<GlobalElement>(new GlobalDefine(@$, value));
};

function:
function_type {
  UniquePtr<FunctionTypeExpression> ft(checked_cast<FunctionTypeExpression*>(list_to_ptr($1)));
  $$ = list_one<GlobalElement>(new Function(@$, ft));
}
| function_type '{' statement_list block_list '}' {
  UniquePtr<FunctionTypeExpression> ft(checked_cast<FunctionTypeExpression*>(list_to_ptr($1)));
  UniqueList<Block> blocks;
  blocks.push_back(*new Block(@3, *$3));
  blocks.splice(blocks.end(), *$4);
  $$ = list_one<GlobalElement>(new Function(@$, ft, blocks));
}
;

function_type:
FUNCTION calling_convention '(' parameter_list ')' '>' expression {
  UniquePtr<Expression> result(list_to_ptr($7));
  UniqueList<NamedExpression> phantom_parameters;
  $$ = list_one<Expression>(new FunctionTypeExpression(@$, $2, phantom_parameters, *$4, result));
}
| FUNCTION calling_convention '(' parameter_list '|' parameter_list ')' '>' expression {
  UniquePtr<Expression> result(list_to_ptr($9));
  $$ = list_one<Expression>(new FunctionTypeExpression(@$, $2, *$4, *$6, result));
};

calling_convention: {$$=cconv_c} | CC_C {$$=cconv_c};

parameter_list: {$$ = list_empty<NamedExpression>();} | parameter_list_nonempty

parameter_list_nonempty:
parameter
| parameter_list ',' parameter {$$ = list_append($1, $3);}
;

parameter: ID ':' expression {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<Expression> type(list_to_ptr($3));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, name, type));
}
| expression {
  UniquePtr<Expression> type(list_to_ptr($1));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, type));
};

block_list: {$$ = list_empty<Block>();} | block_list_nonempty

block_list_nonempty:
block
| block_list_nonempty block {$$ = list_append($1, $2);}
;

block:
BLOCK ID '(' ID ')' ':' statement_list {
  UniquePtr<Token> name(list_to_ptr($2));
  UniquePtr<Token> dominator_name(list_to_ptr($4));
  $$ = list_one<Block>(new Block(@$, name, dominator_name, *$7));
}
| BLOCK ID ':' statement_list {
  UniquePtr<Token> name(list_to_ptr($2));
  UniquePtr<Token> dominator_name;
  $$ = list_one<Block>(new Block(@$, name, dominator_name, *$4));
}
;

statement_list:
statement
| statement_list statement {$$ = list_append($1, $2);}
;

statement:
root_expression ';' {
  UniquePtr<Expression> value(list_to_ptr($1));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, value));
}
| ID '=' root_expression ';' {
  UniquePtr<Token> name(list_to_ptr($1));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<NamedExpression>(new NamedExpression(@$, name, value));
}
;

expression:
NUMBER
| id_expression
| op_expression
| '(' root_expression ')' {$$ = $2;}
;

root_expression:
NUMBER
| id_expression
| bracket_expression
| '(' root_expression ')' {$$ = $2;}
;

id_expression: ID {
  UniquePtr<Token> name(list_to_ptr($1));
  $$ = list_one<Expression>(new NameExpression(@$, name));
};

op_expression: OP {
  UniquePtr<Token> op(list_to_ptr($1));
  UniqueList<Expression> terms;
  $$ = list_one<Expression>(new CallExpression(@$, op, terms));
};

bracket_expression:
OP term_list {
  UniquePtr<Token> op(list_to_ptr($1));
  $$ = list_one<Expression>(new CallExpression(@$, op, *$2));
}
| PHI expression ':' phi_node_list {
  UniquePtr<Expression> type(list_to_ptr($2));
  $$ = list_one<Expression>(new PhiExpression(@$, type, *$4));
}
| function_type
;

term_list: {$$ = list_empty<Expression>();} | term_list_nonempty;

term_list_nonempty:
expression
| term_list_nonempty expression {$$ = list_append($1, $2);}
;

phi_node_list:
phi_node
| phi_node_list ',' phi_node {$$ = list_append($1, $3);}
;

phi_node:
ID '>' expression {
  UniquePtr<Token> label(list_to_ptr($1));
  UniquePtr<Expression> value(list_to_ptr($3));
  $$ = list_one<PhiNode>(new PhiNode(@$, label, value));
}
;

%%

namespace {
  const std::tr1::unordered_map<std::string, int> keywords =
    boost::assign::map_list_of<std::string, int>
    ("block", BLOCK)
    ("const", CONST)
    ("define", DEFINE)
    ("extern", EXTERN)
    ("global", GLOBAL)
    ("function", FUNCTION)
    ("phi", PHI)
    ("cc_tvm", CC_TVM)
    ("cc_c", CC_C);

  const std::tr1::unordered_map<char, LiteralType> signed_literals =
    boost::assign::map_list_of<char, LiteralType>
    ('b', literal_byte)
    ('s', literal_short)
    ('i', literal_int)
    ('l', literal_long)
    ('p', literal_intptr);

  const std::tr1::unordered_map<char, LiteralType> unsigned_literals =
    boost::assign::map_list_of<char, LiteralType>
    ('b', literal_ubyte)
    ('s', literal_ushort)
    ('i', literal_uint)
    ('l', literal_ulong)
    ('p', literal_uintptr);

  /**
   * \brief Scanner function.
   *
   * I've done this as a handwritten function rather than using Flex
   * because bending Flex to my will seems like slightly more effort
   * than doing this. I'd like it to be able to operate on a buffer
   * without altering it, which this function does, and it takes less
   * code than Flex and the myriad of options required to make a Flex
   * scanner sensible.
   *
   * \note Note that this function lives here rather than above the
   * main parser body (where it is declared) because it required the
   * parser token definitions.
   */
  int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, ParserInternalArguments& self) {
#define SCANNER_ACCEPT() (++self.current, ++llocp->last_column)

    while(self.current != self.end) {
      if (std::strchr(" \t\r\v", *self.current)) {
	SCANNER_ACCEPT();
      } else if (*self.current == '\n') {
	++llocp->last_line;
	llocp->last_column = 1;
	SCANNER_ACCEPT();
      } else {
	break;
      }
    }

    if (self.current == self.end)
      return 0;

    llocp->first_line = llocp->last_line;
    llocp->first_column = llocp->last_column;

    int token_type;

    switch(*self.current) {
    case '#':
      token_type = NUMBER;
      SCANNER_ACCEPT();
      break;

    case '%':
      token_type = ID;
      SCANNER_ACCEPT();
      break;

    default:
      if (token_char(*self.current)) {
	token_type = OP;
	break;
      } else {
	char c = *self.current;
	SCANNER_ACCEPT();
	return c;
      }
    }

    const char *start = self.current;

    while ((self.current != self.end) && token_char(*self.current))
      SCANNER_ACCEPT();

    const char *end = self.current;

    if (start == end)
      return INVALID;

    std::string text(start, end);

    if (token_type == OP) {
      std::tr1::unordered_map<std::string, int>::const_iterator it = keywords.find(text);
      if (it != keywords.end())
        return it->second;
    } else if (token_type == NUMBER) {
      if (text.size() < 2)
        return 0;

      std::tr1::unordered_map<char, LiteralType>::const_iterator it;
      std::string literal_text;
      Location literal_loc(*llocp);
      if (text[0] == 'u') {
        it = unsigned_literals.find(text[1]);
        if (it == unsigned_literals.end())
          return 0;
        literal_loc.first_column += 2;
      } else {
        it = signed_literals.find(text[0]);
        if (it == signed_literals.end())
          return 0;
        literal_loc.first_column += 1;
      }

      UniquePtr<Token> literal_token(new Token(literal_loc, literal_text));

      lvalp->expressions = list_one<Expression>(new LiteralExpression(*llocp, it->second, literal_token));
    }

    lvalp->tokens = list_one<Token>(new Token(*llocp, text));
    return token_type;

#undef SCANNER_ADVANCE
  }
}

namespace Psi {
  namespace Tvm {
    namespace Parser {
      Element::Element(const Location& location_) : location(location_) {
      }

      Token::Token(const Location& location_, const std::string& text_)
	: Element(location_), text(text_) {
      }

      Expression::Expression(const Location& location_, ExpressionType expression_type_)
	: Element(location_), expression_type(expression_type_) {
      }

      Expression::~Expression() {
      }

      NameExpression::NameExpression(const Location& location_, UniquePtr<Token>& name_)
	: Expression(location_, expression_name) {
	name.swap(name_);
      }

      NameExpression::~NameExpression() {
      }

      PhiNode::PhiNode(const Location& location_, UniquePtr<Token>& label_, UniquePtr<Expression>& expression_)
	: Element(location_) {
	label.swap(label_);
	expression.swap(expression_);
      }

      PhiNode::~PhiNode() {
      }

      PhiExpression::PhiExpression(const Location& location_, UniquePtr<Expression>& type_, UniqueList<PhiNode>& nodes_)
	: Expression(location_, expression_phi) {
	type.swap(type_);
	nodes.swap(nodes_);
      }

      PhiExpression::~PhiExpression() {
      }

      CallExpression::CallExpression(const Location& location_, UniquePtr<Token>& target_,
				     UniqueList<Expression>& terms_)
	: Expression(location_, expression_call) {
	target.swap(target_);
	terms.swap(terms_);
      }

      CallExpression::~CallExpression() {
      }

      FunctionTypeExpression::FunctionTypeExpression(const Location& location_,
                                                     CallingConvention calling_convention_,
                                                     UniqueList<NamedExpression>& phantom_parameters_,
						     UniqueList<NamedExpression>& parameters_,
						     UniquePtr<Expression>& result_type_)
	: Expression(location_, expression_function_type),
          calling_convention(calling_convention_) {
        phantom_parameters.swap(phantom_parameters_);
	parameters.swap(parameters_);
	result_type.swap(result_type_);
      }

      FunctionTypeExpression::~FunctionTypeExpression() {
      }

      LiteralExpression::LiteralExpression(const Location& location_, LiteralType literal_type_, UniquePtr<Token>& value_)
        : Expression(location_, expression_literal),
          literal_type(literal_type_) {
        value.swap(value_);
      }

      LiteralExpression::~LiteralExpression() {
      }

      NamedExpression::NamedExpression(const Location& location_, UniquePtr<Token>& name_, UniquePtr<Expression>& expression_)
	: Element(location_) {
	name.swap(name_);
	expression.swap(expression_);
      }

      NamedExpression::NamedExpression(const Location& location_, UniquePtr<Expression>& expression_)
	: Element(location_) {
	expression.swap(expression_);
      }

      NamedExpression::~NamedExpression() {
      }

      Block::Block(const Location& location_, UniquePtr<Token>& name_,
                   UniquePtr<Token>& dominator_name_,
                   UniqueList<NamedExpression>& statements_)
	: Element(location_) {
	name.swap(name_);
        dominator_name.swap(dominator_name_);
	statements.swap(statements_);
      }

      Block::Block(const Location& location_,
                   UniqueList<NamedExpression>& statements_)
	: Element(location_) {
	statements.swap(statements_);
      }

      Block::~Block() {
      }

      GlobalElement::GlobalElement(const Location& location_, GlobalType global_type_)
	: Element(location_), global_type(global_type_) {
      }

      GlobalElement::~GlobalElement() {
      }

      Function::Function(const Location& location_,
			 UniquePtr<FunctionTypeExpression>& type_)
	: GlobalElement(location_, global_function) {
	type.swap(type_);
      }

      Function::Function(const Location& location_,
			 UniquePtr<FunctionTypeExpression>& type_,
			 UniqueList<Block>& blocks_)
	: GlobalElement(location_, global_function) {
	type.swap(type_);
	blocks.swap(blocks_);
      }

      Function::~Function() {
      }

      GlobalVariable::GlobalVariable(const Location& location_,
                                     bool constant_,
				     UniquePtr<Expression>& type_)
	: GlobalElement(location_, global_variable),
          constant(constant_) {
	type.swap(type_);
      }

      GlobalVariable::GlobalVariable(const Location& location_,
                                     bool constant_,
				     UniquePtr<Expression>& type_,
				     UniquePtr<Expression>& value_)
	: GlobalElement(location_, global_variable),
          constant(constant_) {
	type.swap(type_);
	value.swap(value_);
      }

      GlobalVariable::~GlobalVariable() {
      }

      GlobalDefine::GlobalDefine(const Location& location_,
		     UniquePtr<Expression>& value_)
	: GlobalElement(location_, global_define) {
	value.swap(value_);
      }

      GlobalDefine::~GlobalDefine() {
      }

      NamedGlobalElement::NamedGlobalElement(const Location& location_, UniquePtr<Token>& name_, UniquePtr<GlobalElement>& value_)
	: Element(location_) {
	name.swap(name_);
	value.swap(value_);
      }

      NamedGlobalElement::~NamedGlobalElement() {
      }
    }

    void parse(UniqueList<Parser::NamedGlobalElement>& result, const char *begin, const char *end) {
      ParserInternalArguments ia(begin, end);
      yyparse(ia);
      if (!ia.error_message.empty()) {
	throw std::logic_error(ia.error_message);
      } else {
	result.swap(ia.result);
      }
    }

    void parse(UniqueList<Parser::NamedGlobalElement>& result, const char *begin) {
      parse(result, begin, begin+std::strlen(begin));
    }
  }
}
